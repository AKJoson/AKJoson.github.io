<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Android源码阅读之———广播的注册与分发 | 出发的越久,也要记得当初的目的</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="这一节去分析一下广播的注册，广播消息的分发过程。 一些概念： 无序广播：默认发送的就是无序广播，所有注册了的广播几乎在同一时刻接收到广播消息； 有序广播：优先级越高越先收到，传递过程中，可以控制结束该广播，也可以修改传递数据； 粘性消息：发送的粘性消息一直存放在AMS中，当注册广播时，如果之前已经有粘性消息存在，则直接派发。  12345678910111213141516171819202122">
<meta property="og:type" content="article">
<meta property="og:title" content="Android源码阅读之———广播的注册与分发">
<meta property="og:url" content="http://example.com/2025/03/24/20250324/index.html">
<meta property="og:site_name" content="出发的越久,也要记得当初的目的">
<meta property="og:description" content="这一节去分析一下广播的注册，广播消息的分发过程。 一些概念： 无序广播：默认发送的就是无序广播，所有注册了的广播几乎在同一时刻接收到广播消息； 有序广播：优先级越高越先收到，传递过程中，可以控制结束该广播，也可以修改传递数据； 粘性消息：发送的粘性消息一直存放在AMS中，当注册广播时，如果之前已经有粘性消息存在，则直接派发。  12345678910111213141516171819202122">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-03-24T07:37:00.000Z">
<meta property="article:modified_time" content="2025-07-28T06:43:21.180Z">
<meta property="article:author" content="Cherry">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="出发的越久,也要记得当初的目的" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">出发的越久,也要记得当初的目的</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">加油,努力</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-20250324" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/24/20250324/" class="article-date">
  <time class="dt-published" datetime="2025-03-24T07:37:00.000Z" itemprop="datePublished">2025-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Android源码阅读之———广播的注册与分发
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="这一节去分析一下广播的注册，广播消息的分发过程。"><a href="#这一节去分析一下广播的注册，广播消息的分发过程。" class="headerlink" title="这一节去分析一下广播的注册，广播消息的分发过程。"></a>这一节去分析一下广播的注册，广播消息的分发过程。</h4><hr>
<h5 id="一些概念："><a href="#一些概念：" class="headerlink" title="一些概念："></a>一些概念：</h5><ol>
<li>无序广播：默认发送的就是无序广播，所有注册了的广播几乎在同一时刻接收到广播消息；</li>
<li>有序广播：优先级越高越先收到，传递过程中，可以控制结束该广播，也可以修改传递数据；</li>
<li>粘性消息：发送的粘性消息一直存放在AMS中，当注册广播时，如果之前已经有粘性消息存在，则直接派发。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#ContextImpl$registerReceiver</span><br><span class="line">private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId,</span><br><span class="line">        IntentFilter filter, String broadcastPermission,</span><br><span class="line">        Handler scheduler, Context context, int flags) &#123; </span><br><span class="line">    //注意这个IIntentReceiver，看名字就知道是个接口。在AndroidStudio中找不到。一搜索，咦，这是个aidl文件。</span><br><span class="line">    //我们知道这个IIntentReceiver用于Binder通信，且在此是作为服务端。</span><br><span class="line">    IIntentReceiver rd = null;</span><br><span class="line">    if (receiver != null) &#123;</span><br><span class="line">        if (mPackageInfo != null &amp;&amp; context != null) &#123;</span><br><span class="line">            if (scheduler == null) &#123;</span><br><span class="line">                //ActivityThread中的mH，是一个Handler</span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">       (1)   //mPackageInfo是LoaderApk类型，其中创建了ReceiverDispatcher，这个类内部有一个</span><br><span class="line">            // InnerReceiver extends IIntentReceiver.Stub 这个InnerReceiver继承了IIntentReceiver.Stub</span><br><span class="line">            // rd 作为服务端，用于接收广播接收</span><br><span class="line">            rd = mPackageInfo.getReceiverDispatcher(</span><br><span class="line">                receiver, context, scheduler,</span><br><span class="line">                mMainThread.getInstrumentation(), true);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (scheduler == null) &#123;</span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            rd = new LoadedApk.ReceiverDispatcher(</span><br><span class="line">                    receiver, context, scheduler, null, true).getIIntentReceiver();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        //注意此处有一个Intent的返回，另外传入的参数有ApplicationThread和IIntentReceiver和IntentFilter</span><br><span class="line">        final Intent intent = ActivityManager.getService().registerReceiver(</span><br><span class="line">                mMainThread.getApplicationThread(), mBasePackageName, rd, filter,</span><br><span class="line">                broadcastPermission, userId, flags);</span><br><span class="line">        if (intent != null) &#123;</span><br><span class="line">            intent.setExtrasClassLoader(getClassLoader());</span><br><span class="line">            intent.prepareToEnterProcess();</span><br><span class="line">        &#125;</span><br><span class="line">        return intent; //把intent返回回去</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-上面获取IIntentReceiver这个binder的时候，涉及到了LoadedApk这个类，内部有一个ReceiverDispatcher的内部类，ReceiverDispatcher这个类的内部有一个InnerReceiver实现了IIntentReceiver-Stub-具有了跨进程通信功能。也就是说接收然后分发广播，这个动作会在LoadedApk的InnerReceiver。那么我们看一下数据LoadedApk中的数据结构："><a href="#1-上面获取IIntentReceiver这个binder的时候，涉及到了LoadedApk这个类，内部有一个ReceiverDispatcher的内部类，ReceiverDispatcher这个类的内部有一个InnerReceiver实现了IIntentReceiver-Stub-具有了跨进程通信功能。也就是说接收然后分发广播，这个动作会在LoadedApk的InnerReceiver。那么我们看一下数据LoadedApk中的数据结构：" class="headerlink" title="(1)  上面获取IIntentReceiver这个binder的时候，涉及到了LoadedApk这个类，内部有一个ReceiverDispatcher的内部类，ReceiverDispatcher这个类的内部有一个InnerReceiver实现了IIntentReceiver.Stub,具有了跨进程通信功能。也就是说接收然后分发广播，这个动作会在LoadedApk的InnerReceiver。那么我们看一下数据LoadedApk中的数据结构："></a>(1)  上面获取IIntentReceiver这个binder的时候，涉及到了LoadedApk这个类，内部有一个ReceiverDispatcher的内部类，ReceiverDispatcher这个类的内部有一个InnerReceiver实现了IIntentReceiver.Stub,具有了跨进程通信功能。也就是说接收然后分发广播，这个动作会在LoadedApk的InnerReceiver。那么我们看一下数据LoadedApk中的数据结构：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//LoadedApk的全局变量</span><br><span class="line">//context上下文作为key,value也是一个Map，这个Map是以BroadcastReceiver位key, ReceiverDispatcher为value</span><br><span class="line">private final ArrayMap&lt;Context, ArrayMap&lt;BroadcastReceiver, ReceiverDispatcher&gt;&gt; mReceivers</span><br><span class="line">    = new ArrayMap&lt;&gt;();</span><br><span class="line">private final ArrayMap&lt;Context, ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;&gt; mUnregisteredReceivers</span><br><span class="line">    = new ArrayMap&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h4 id="困难九十九，难不倒两只手。进入AMS，查看registerReceiver"><a href="#困难九十九，难不倒两只手。进入AMS，查看registerReceiver" class="headerlink" title="困难九十九，难不倒两只手。进入AMS，查看registerReceiver"></a>困难九十九，难不倒两只手。进入AMS，查看registerReceiver</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">#ActivityManagerService.java$registerReceiver</span><br><span class="line">//传入的参数第一个是：IApplicationThread，后面还有一个IIntentReceiver，都具有RPC能力。</span><br><span class="line">public Intent registerReceiver(IApplicationThread caller, String callerPackage,</span><br><span class="line">        IIntentReceiver receiver, IntentFilter filter, String permission, int userId,</span><br><span class="line">        int flags) &#123;</span><br><span class="line">    ArrayList&lt;Intent&gt; stickyIntents = null;//一个粘性意图的列表悄然出现</span><br><span class="line">    ProcessRecord callerApp = null;//似乎是记录进程的一个类</span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        if (caller != null) &#123;</span><br><span class="line">           //根据IApplicationThread这个Binder去寻找ProcessRecord,这个类，似乎管控着所有启动的Application</span><br><span class="line">           //另外还有一点，就是这个IApplicationThread是在ActivityThread中初始化的，ActivityThread又属于app入口点，所以一个app进程只有一个IApplicationThread</span><br><span class="line">            callerApp = getRecordForAppLocked(caller); </span><br><span class="line">        &#125; </span><br><span class="line">        //取出本次要注册广播的Action，准备进行迭代</span><br><span class="line">        Iterator&lt;String&gt; actions = filter.actionsIterator();</span><br><span class="line">        if (actions == null) &#123;</span><br><span class="line">            ArrayList&lt;String&gt; noAction = new ArrayList&lt;String&gt;(1);</span><br><span class="line">            noAction.add(null);</span><br><span class="line">            actions = noAction.iterator();</span><br><span class="line">        &#125;</span><br><span class="line">        // Collect stickies of users</span><br><span class="line">        int[] userIds = &#123; UserHandle.USER_ALL, UserHandle.getUserId(callingUid) &#125;;</span><br><span class="line">        while (actions.hasNext()) &#123;</span><br><span class="line">            String action = actions.next();//遍历action</span><br><span class="line">            for (int id : userIds) &#123;</span><br><span class="line">//mStickyBroadcasts类型是SparseArray&lt;ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt;&gt;，SparseArray映射一个Integer到一个Object</span><br><span class="line">                ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(id);</span><br><span class="line">                if (stickies != null) &#123;</span><br><span class="line">                    ArrayList&lt;Intent&gt; intents = stickies.get(action);</span><br><span class="line">                    if (intents != null) &#123;</span><br><span class="line">                        if (stickyIntents == null) &#123;</span><br><span class="line">                            stickyIntents = new ArrayList&lt;Intent&gt;();</span><br><span class="line">                        &#125;</span><br><span class="line">                        //根据本次的action找到粘性事件的Intent</span><br><span class="line">                        stickyIntents.addAll(intents);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Intent&gt; allSticky = null;</span><br><span class="line">    if (stickyIntents != null) &#123;</span><br><span class="line">        final ContentResolver resolver = mContext.getContentResolver();</span><br><span class="line">        // Look for any matching sticky broadcasts...</span><br><span class="line">        for (int i = 0, N = stickyIntents.size(); i &lt; N; i++) &#123;</span><br><span class="line">            Intent intent = stickyIntents.get(i);</span><br><span class="line">            //我正在注册广播接收器，你问我是否和AMS中存在的粘性广播匹配。</span><br><span class="line">            //那是啥子意思嘛？很明显，就是你注册的这个广播接收器，怕是想接收已经存在的粘性事件。</span><br><span class="line">            if (filter.match(resolver, intent, true, TAG) &gt;= 0) &#123;</span><br><span class="line">                if (allSticky == null) &#123;</span><br><span class="line">                    allSticky = new ArrayList&lt;Intent&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                //匹配加入进来，是否这些粘性intent就是要分发给正在注册的这个广播了？我们按照着剧本往下走。</span><br><span class="line">                allSticky.add(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // The first sticky in the list is returned directly back to the client.</span><br><span class="line">    Intent sticky = allSticky != null ? allSticky.get(0) : null; //确实有粘性事件的Intent匹配当前要注册的Fliter，那么返回第一个,要么是NUll！</span><br><span class="line">    if (receiver == null) &#123;</span><br><span class="line">//也就是我们可以通过registerBoradCastReceiver(null,IntentFliter(action))，根据返回判定是否存在粘性广播</span><br><span class="line">        return sticky;  //intent = registerBoradCastReceiver(null,IntentFliter(action)),这种方式注册的广播，已经拿到了他想要的粘性事件结果Intent，剧本结束。</span><br><span class="line">    &#125;</span><br><span class="line">    //剧本走到这里，有可能这次注册，监听的Action的确是粘性事件，但是他有传入receiver</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        //HashMap&lt;IBinder, ReceiverList&gt;  mRegisteredReceivers，键是IIntentReceiver</span><br><span class="line">        //receiver是IIntentReceiver,这个东西和Context一一对应，也就是Activity, 也就是这边AMS这里一个ReceiverList包含了一个Activity里所有注册了的广播。</span><br><span class="line">        ReceiverList rl = mRegisteredReceivers.get(receiver.asBinder()); </span><br><span class="line">        if (rl == null) &#123;</span><br><span class="line">            rl = new ReceiverList(this, callerApp, callingPid, callingUid,</span><br><span class="line">                    userId, receiver);</span><br><span class="line">            if (rl.app != null) &#123;</span><br><span class="line">                // rl.app.receivers.size() 表示的是一个app注册的所有的广播，MAX_RECEIVERS_ALLOWED_PER_APP是1000，什么意思？</span><br><span class="line">                //一个app最多只能注册1000个广播。</span><br><span class="line">                final int totalReceiversForApp = rl.app.receivers.size(); </span><br><span class="line">                if (totalReceiversForApp &gt;= MAX_RECEIVERS_ALLOWED_PER_APP) &#123;</span><br><span class="line">                    throw new IllegalStateException(&quot;Too many receivers, total of &quot;</span><br><span class="line">                            + totalReceiversForApp + &quot;, registered for pid: &quot;</span><br><span class="line">                            + rl.pid + &quot;, callerPackage: &quot; + callerPackage);</span><br><span class="line">                &#125;</span><br><span class="line">                rl.app.receivers.add(rl); //没超出最大数量，添加进去。</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    receiver.asBinder().linkToDeath(rl, 0);</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    return sticky;</span><br><span class="line">                &#125;</span><br><span class="line">                rl.linkedToDeath = true;</span><br><span class="line">            &#125;</span><br><span class="line">            //添加注册信息</span><br><span class="line">            mRegisteredReceivers.put(receiver.asBinder(), rl);</span><br><span class="line">        &#125;</span><br><span class="line">        //引入一个BroadcasrFilter，包含了上面的ReceiverList，本次广播的filter也存入BroadcastFilter中</span><br><span class="line">        BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage,</span><br><span class="line">                permission, callingUid, userId, instantApp, visibleToInstantApps);</span><br><span class="line">         rl.add(bf);  // bf中有rl,rl中有bf。你中有我，我中有你。同时这行代码的含义：向ReceiverList添加一个广播。等同于：当前activity又新注册了一个广播。</span><br><span class="line">        //IntentResolver&lt;BroadcastFilter, BroadcastFilter&gt; mReceiverResolver</span><br><span class="line">         mReceiverResolver.addFilter(bf); //到此处新增加的广播在AMS中就处理完毕了,下面还有一个粘性事件的分发处理。</span><br><span class="line">        // Enqueue broadcasts for all existing stickies that match</span><br><span class="line">        // this filter.</span><br><span class="line">        if (allSticky != null) &#123;//看样子要处理这个粘性事件的问题</span><br><span class="line">            ArrayList receivers = new ArrayList();</span><br><span class="line">            receivers.add(bf);</span><br><span class="line">            final int stickyCount = allSticky.size();</span><br><span class="line">            for (int i = 0; i &lt; stickyCount; i++) &#123;</span><br><span class="line">                Intent intent = allSticky.get(i);</span><br><span class="line">                //引入BroadcastQueue,两个队列：一个是前台队列，一个是后台队列。就是使用哪一个根据intent的flag来确定。</span><br><span class="line">                BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line">                //BroadcastRecord主要是包含了receivers</span><br><span class="line">                BroadcastRecord r = new BroadcastRecord(queue, intent, null,</span><br><span class="line">                        null, -1, -1, false, null, null, OP_NONE, null, receivers,</span><br><span class="line">                        null, 0, null, null, false, true, true, -1, false,</span><br><span class="line">                        false /* only PRE_BOOT_COMPLETED should be exempt, no stickies */);</span><br><span class="line">                queue.enqueueParallelBroadcastLocked(r); //入队</span><br><span class="line">                queue.scheduleBroadcastsLocked(); //分发广播</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sticky;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="对上面注册广播接收器进行小总结一下"><a href="#对上面注册广播接收器进行小总结一下" class="headerlink" title="对上面注册广播接收器进行小总结一下:"></a>对上面注册广播接收器进行小总结一下:</h5><ul>
<li>从app端过来的信息主要是IApplicationThread、IIntentReceiver、IntentFilter<ul>
<li><p>IApplicationThread用于确定到底是哪个app在搞事情</p>
</li>
<li><p>IIntentReceiver对标于Context, 而Context本身是一个Activity一个。那么这就产生一个问题：一个Activity注册多个广播，是怎么搞的？ </p>
<ul>
<li>答:mReceivers的数据类型是Map, key是Context, value是Map,key是broadcast,value 是ReceiverDispatcher.</li>
</ul>
</li>
<li><p>IntentFilter主要就是取其Action,标识其关注的广播。</p>
</li>
</ul>
</li>
<li>rl &#x3D; new ReceiverList(this, callerApp, callingPid, callingUid,userId, receiver);</li>
<li>mRegisteredReceivers.put(receiver.asBinder(), rl);</li>
<li>bf &#x3D; new BroadcastFilter(filter, rl, callerPackage,permission, callingUid, userId, instantApp, visibleToInstantApps);</li>
<li>mReceiverResolver.addFilter(bf);</li>
</ul>
<h4 id="上面广播的注册，处理的最多的还是这个粘性事件。同时通过上面代码的阅读，我们知道要是想获取一个粘性广播的消息，我们只需要这样"><a href="#上面广播的注册，处理的最多的还是这个粘性事件。同时通过上面代码的阅读，我们知道要是想获取一个粘性广播的消息，我们只需要这样" class="headerlink" title="上面广播的注册，处理的最多的还是这个粘性事件。同时通过上面代码的阅读，我们知道要是想获取一个粘性广播的消息，我们只需要这样"></a>上面广播的注册，处理的最多的还是这个粘性事件。同时通过上面代码的阅读，我们知道要是想获取一个粘性广播的消息，我们只需要这样</h4><p><strong>intent &#x3D; registerReceiver(null,IntentFliter(action)),这样从返回的这个intent，我们就可以获取到粘性事件的数据(当然也可能为null),如果你注册还是传入了receiver,又恰好有粘性事件，那么这正是我们下面要分析的：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">//接着分析上面遗留的小尾巴</span><br><span class="line">//queue.enqueueParallelBroadcastLocked(r); //入队</span><br><span class="line">    public void enqueueParallelBroadcastLocked(BroadcastRecord r) &#123;</span><br><span class="line">        mParallelBroadcasts.add(r); //类型是 ArrayList&lt;BroadcastRecord&gt; mParallelBroadcasts</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void enqueueOrderedBroadcastLocked(BroadcastRecord r) &#123;</span><br><span class="line">        mDispatcher.enqueueOrderedBroadcastLocked(r); //这个方法见名知意，当前广播加入有序广播</span><br><span class="line">    &#125;</span><br><span class="line">//queue.scheduleBroadcastsLocked(); //分发广播</span><br><span class="line">    public void scheduleBroadcastsLocked() &#123;</span><br><span class="line">        if (mBroadcastsScheduled) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //使用Handler去处理事情，这个Handler是在AMS构造的时候，创建的一个ServiceThread,继承自HandlerThread。</span><br><span class="line">        //也就是开了一个线程来处理这些广播分发的动作。</span><br><span class="line">        mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));</span><br><span class="line">        mBroadcastsScheduled = true;</span><br><span class="line">    &#125;</span><br><span class="line">//mHandler中调用processNextBroadcast(true);</span><br><span class="line">final void processNextBroadcast(boolean fromMsg) &#123;</span><br><span class="line">        synchronized (mService) &#123;</span><br><span class="line">            processNextBroadcastLocked(fromMsg, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">final void processNextBroadcastLocked(boolean fromMsg, boolean skipOomAdj) &#123;</span><br><span class="line">    while (mParallelBroadcasts.size() &gt; 0) &#123;</span><br><span class="line">        r = mParallelBroadcasts.remove(0);</span><br><span class="line">        final int N = r.receivers.size();</span><br><span class="line">        for (int i=0; i&lt;N; i++) &#123;//开启for循环的时候就是故事开始的时候</span><br><span class="line">            Object target = r.receivers.get(i);</span><br><span class="line">            //分发</span><br><span class="line">            deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false, i);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">private void deliverToRegisteredReceiverLocked(BroadcastRecord r,</span><br><span class="line">        BroadcastFilter filter, boolean ordered, int index) &#123;</span><br><span class="line">    boolean skip = false;</span><br><span class="line">    ...</span><br><span class="line">    if (skip) &#123;</span><br><span class="line">    r.delivery[index] = BroadcastRecord.DELIVERY_SKIPPED;</span><br><span class="line">    return;</span><br><span class="line">    &#125;</span><br><span class="line">   if (filter.receiverList.app != null &amp;&amp; filter.receiverList.app.inFullBackup) &#123;</span><br><span class="line">                // Skip delivery if full backup in progress</span><br><span class="line">                // If it&#x27;s an ordered broadcast, we need to continue to the next receiver.</span><br><span class="line">                if (ordered) &#123;</span><br><span class="line">                    skipReceiverLocked(r); //这里面有点意思，通过下面的分析就知道，这里进行了循环。</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                maybeAddAllowBackgroundActivityStartsToken(filter.receiverList.app, r);</span><br><span class="line">                //分发</span><br><span class="line">                performReceiveLocked(filter.receiverList.app, filter.receiverList.receiver,</span><br><span class="line">                        new Intent(r.intent), r.resultCode, r.resultData,</span><br><span class="line">                        r.resultExtras, r.ordered, r.initialSticky, r.userId);</span><br><span class="line">                // parallel broadcasts are fire-and-forget, not bookended by a call to</span><br><span class="line">                // finishReceiverLocked(), so we manage their activity-start token here</span><br><span class="line">                if (r.allowBackgroundActivityStarts &amp;&amp; !r.ordered) &#123;</span><br><span class="line">                    postActivityStartTokenRemoval(filter.receiverList.app, r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (ordered) &#123;</span><br><span class="line">                r.state = BroadcastRecord.CALL_DONE_RECEIVE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//skipReceiverLocked</span><br><span class="line">private void skipReceiverLocked(BroadcastRecord r) &#123;</span><br><span class="line">        logBroadcastReceiverDiscardLocked(r);</span><br><span class="line">        finishReceiverLocked(r, r.resultCode, r.resultData,</span><br><span class="line">                r.resultExtras, r.resultAbort, false);</span><br><span class="line">        scheduleBroadcastsLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    public void scheduleBroadcastsLocked() &#123;</span><br><span class="line">        if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Schedule broadcasts [&quot;</span><br><span class="line">                + mQueueName + &quot;]: current=&quot;</span><br><span class="line">                + mBroadcastsScheduled);</span><br><span class="line">        if (mBroadcastsScheduled) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));</span><br><span class="line">        mBroadcastsScheduled = true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="最后的派发performReceiveLocked"><a href="#最后的派发performReceiveLocked" class="headerlink" title="最后的派发performReceiveLocked"></a>最后的派发performReceiveLocked</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver,</span><br><span class="line">        Intent intent, int resultCode, String data, Bundle extras,</span><br><span class="line">        boolean ordered, boolean sticky, int sendingUser)</span><br><span class="line">        throws RemoteException &#123;</span><br><span class="line">    // Send the intent to the receiver asynchronously using one-way binder calls.</span><br><span class="line">    if (app != null) &#123;</span><br><span class="line">        if (app.thread != null) &#123;</span><br><span class="line">//走这里从applicationThread进行RPC,binder通信回调回去。注意上面的注释，说这个事one-way也就是单向，调用了就行，不需要等待回复的。</span><br><span class="line">//进入ActivityThread我们会发现，其实调用的就是receiver.performReceive</span><br><span class="line">                app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,</span><br><span class="line">                        data, extras, ordered, sticky, sendingUser, app.getReportedProcState());</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">//这里就不一样了使用IIntentReceiver，这里的receiver是代理端，发起远程RPC,回调回LoadedApk中,进行广播派发。</span><br><span class="line">        receiver.performReceive(intent, resultCode, data, extras, ordered,</span><br><span class="line">                sticky, sendingUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>上面的消息派发都是使用receiver.performReceive，有什么区别了？使用applicationThread回调回去的，是在app自己的进程派发。在AMS中调用receiver.performReceive时跨进程的binder call调用派发消息。</strong></p>
<h4 id="万万没有想到我只是想分析一下广播的注册，没想到分发也引入进来了。ok-话不多说，接着我们真正的开始广播的发送。"><a href="#万万没有想到我只是想分析一下广播的注册，没想到分发也引入进来了。ok-话不多说，接着我们真正的开始广播的发送。" class="headerlink" title="万万没有想到我只是想分析一下广播的注册，没想到分发也引入进来了。ok,话不多说，接着我们真正的开始广播的发送。"></a>万万没有想到我只是想分析一下广播的注册，没想到分发也引入进来了。ok,话不多说，接着我们真正的开始广播的发送。</h4><ul>
<li>sendBroadcast()    普通广播</li>
<li>sendOrderedBroadcast    有序广播</li>
<li>sendStickyBroadcast ，Sticky broadcasts should not be used. 粘性广播在高版本的API上已经被废弃掉了，后面的解释说是任何用户都可以访问，同时也可以修改，非常的不安全！</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#ContextImpl$sendBroadcast</span><br><span class="line">@Override</span><br><span class="line">public void sendBroadcast(Intent intent) &#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());</span><br><span class="line">    try &#123;</span><br><span class="line">        intent.prepareToLeaveProcess(this);</span><br><span class="line">        //发送不是注册，不需要考虑如何接收的问题，因此来的简单粗暴一些。带上Intent,直接就进入AMS中</span><br><span class="line">        ActivityManager.getService().broadcastIntent(</span><br><span class="line">                mMainThread.getApplicationThread(), intent, resolvedType, null,</span><br><span class="line">                Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false,</span><br><span class="line">                getUserId());</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="进入AMS去查看broadcastIntent"><a href="#进入AMS去查看broadcastIntent" class="headerlink" title="进入AMS去查看broadcastIntent"></a>进入AMS去查看broadcastIntent</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">final int broadcastIntentLocked(ProcessRecord callerApp,</span><br><span class="line">        String callerPackage, Intent intent, String resolvedType,</span><br><span class="line">        IIntentReceiver resultTo, int resultCode, String resultData,</span><br><span class="line">        Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle bOptions,</span><br><span class="line">        boolean ordered, boolean sticky, int callingPid, int callingUid, int realCallingUid,</span><br><span class="line">        int realCallingPid, int userId, boolean allowBackgroundActivityStarts) &#123;</span><br><span class="line">    intent = new Intent(intent);//重新构建一个本地的Intent，这是为何？</span><br><span class="line">  // By default broadcasts do not go to stopped apps.</span><br><span class="line">intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES); //停止的app不在派发</span><br><span class="line">final String action = intent.getAction();</span><br><span class="line">if (action != null) &#123;</span><br><span class="line">    switch (action) &#123; //下面的这些ACTION,看到名字就知道是PKMS发送过来的，</span><br><span class="line">        case Intent.ACTION_PACKAGE_REMOVED: //当app移除，就会去清除当前app的堆栈信息，具体的等分析PKMS再来进行分析。</span><br><span class="line">        case Intent.ACTION_PACKAGE_CHANGED:</span><br><span class="line">        ...</span><br><span class="line">if (sticky) &#123;</span><br><span class="line">    //上面我们看到发送粘性广播的API已经废弃，但是这里面还是有的，应该是留给系统使用的，需要一个权限：android.permission.BROADCAST_STICKY</span><br><span class="line">    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,</span><br><span class="line">            callingPid, callingUid)</span><br><span class="line">            != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">        throw new SecurityException(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(userId);</span><br><span class="line">    if (stickies == null) &#123;</span><br><span class="line">        stickies = new ArrayMap&lt;&gt;();</span><br><span class="line">        mStickyBroadcasts.put(userId, stickies); //粘性广播加入集合</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Intent&gt; list = stickies.get(intent.getAction());</span><br><span class="line">    if (list == null) &#123;</span><br><span class="line">        list = new ArrayList&lt;&gt;();</span><br><span class="line">        stickies.put(intent.getAction(), list);&#125;</span><br><span class="line">    final int stickiesCount = list.size();</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; stickiesCount; i++) &#123;</span><br><span class="line">    if (intent.filterEquals(list.get(i))) &#123;</span><br><span class="line">        // This sticky already exists, replace it.</span><br><span class="line">        list.set(i, new Intent(intent));</span><br><span class="line">        break;&#125;&#125;</span><br><span class="line">if (i &gt;= stickiesCount) &#123;</span><br><span class="line">    list.add(new Intent(intent));&#125;&#125; </span><br><span class="line">//上面完成了对粘性消息的处理</span><br><span class="line">// Figure out who all will receive this broadcast. </span><br><span class="line">List receivers = null; //看来要开始找出接收者了</span><br><span class="line">List&lt;BroadcastFilter&gt; registeredReceivers = null;</span><br><span class="line">if ((intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY)// 设置了这个Flag表示只分发给动态广播，没设置，默认，走下面去PKMS中把静态广播也一起找出来。</span><br><span class="line">         == 0) &#123;</span><br><span class="line"> //这个receivers是List&lt;ResolveInfo&gt;，并且下面这个方法看一下就知道，是在访问PKMS,找到匹配当前Intent的广播接收器</span><br><span class="line">    receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);</span><br><span class="line">&#125;</span><br><span class="line">//这个mReceiverResolver在注册广播的时候，最后: mReceiverResolver.addFliter(bf),看来就在这里去匹配的</span><br><span class="line">//所有动态注册的广播，全部出场，最后还有一个mResolvePrioritySorter,用于按照优先级排序，看来已经考虑到顺序广播。</span><br><span class="line">    registeredReceivers = mReceiverResolver.queryIntent(intent,</span><br><span class="line">        resolvedType, false /*defaultOnly*/, userId);</span><br><span class="line">// Merge into one list. 要给静态广播和动态合并在一块好进行一个分发</span><br><span class="line">if (receivers != null) &#123; //如果静态广播不为空</span><br><span class="line">    // A special case for PACKAGE_ADDED: do not allow the package</span><br><span class="line">    // being added to see this broadcast.  This prevents them from</span><br><span class="line">    // using this as a back door to get run as soon as they are</span><br><span class="line">    // installed.   </span><br><span class="line">    //上面这段注释加上下面这段代码的意思就是：</span><br><span class="line">    //当前的这个广播如果是下面几种类型的，同时我们搜索到的静态广播也监听这几个action,那么就应该把这几个静态广播移除出去，</span><br><span class="line">    //这样就可以避免一种情况就是：1. 应用刚安装就自己启动了，2. 用户刚点击了清除应用数据，应用就启动了。</span><br><span class="line">    String skipPackages[] = null;</span><br><span class="line">    if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())</span><br><span class="line">            || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction())</span><br><span class="line">            || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) &#123;</span><br><span class="line">        Uri data = intent.getData();</span><br><span class="line">        if (data != null) &#123;</span><br><span class="line">            String pkgName = data.getSchemeSpecificPart();</span><br><span class="line">            if (pkgName != null) &#123;</span><br><span class="line">                skipPackages = new String[] &#123; pkgName &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) &#123;</span><br><span class="line">        skipPackages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);</span><br><span class="line">    &#125;</span><br><span class="line">    if (skipPackages != null &amp;&amp; (skipPackages.length &gt; 0)) &#123;</span><br><span class="line">        for (String skipPackage : skipPackages) &#123;</span><br><span class="line">            if (skipPackage != null) &#123;</span><br><span class="line">                int NT = receivers.size();</span><br><span class="line">                for (int it=0; it&lt;NT; it++) &#123;</span><br><span class="line">                    ResolveInfo curt = (ResolveInfo)receivers.get(it);</span><br><span class="line">                    if (curt.activityInfo.packageName.equals(skipPackage)) &#123;</span><br><span class="line">                        receivers.remove(it);</span><br><span class="line">                        it--;</span><br><span class="line">                        NT--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //通过上面的移除，下面要真正的开始将静态和动态广播合并到一个了</span><br><span class="line">    int NT = receivers != null ? receivers.size() : 0;</span><br><span class="line">    int it = 0;</span><br><span class="line">    int ir = 0;</span><br><span class="line">    ResolveInfo curt = null;// 静态广播对应数据类型</span><br><span class="line">    BroadcastFilter curr = null;// 动态广播对应类型</span><br><span class="line">    //注意到上面两种广播的数据类型根本不一样，两种类型不一样的要合并在一起，这是一个有趣的事情，看看google工程师怎么搞的事情：</span><br><span class="line">    while (it &lt; NT &amp;&amp; ir &lt; NR) &#123;</span><br><span class="line">        if (curt == null) &#123;</span><br><span class="line">            curt = (ResolveInfo)receivers.get(it); //取出第it个静态广播</span><br><span class="line">        &#125;</span><br><span class="line">        if (curr == null) &#123;</span><br><span class="line">            curr = registeredReceivers.get(ir); //取出第ir个动态广播</span><br><span class="line">        &#125;</span><br><span class="line">        if (curr.getPriority() &gt;= curt.priority) &#123; //两个广播进行优先级比较</span><br><span class="line">            // Insert this broadcast record into the final list.</span><br><span class="line">            receivers.add(it, curr);//？？动态的BroadcastFilter 插入静态的ResolveInfo列表？？不是，等等，这个类型不是不一样嘛</span><br><span class="line">            ir++;</span><br><span class="line">            curr = null; //准备取下一个动态</span><br><span class="line">            it++;</span><br><span class="line">            NT++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Skip to the next ResolveInfo in the final list.</span><br><span class="line">            it++;</span><br><span class="line">            curt = null; //静态广播优先级大，在这个位置不动，取下一个静态广播和当前动态广播相比较</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">while (ir &lt; NR) &#123; //动态广播还没有取完，把最后剩于的加入列表末尾。</span><br><span class="line">    if (receivers == null) &#123;</span><br><span class="line">        receivers = new ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line">    receivers.add(registeredReceivers.get(ir));</span><br><span class="line">    ir++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="上面把动态广播的BroadcastFilter加入静态receivers-ResolveInfo-List的动作-是因为List-receivers-null-这个List没有指定是什么类型的，默认存放的是Object类型，所以静态动态被存放在了同一个里面。另外我们已经得到能够接收的列表，而且按照优先权来拍好了序，看来就只差最后一步了：分发。"><a href="#上面把动态广播的BroadcastFilter加入静态receivers-ResolveInfo-List的动作-是因为List-receivers-null-这个List没有指定是什么类型的，默认存放的是Object类型，所以静态动态被存放在了同一个里面。另外我们已经得到能够接收的列表，而且按照优先权来拍好了序，看来就只差最后一步了：分发。" class="headerlink" title="上面把动态广播的BroadcastFilter加入静态receivers(ResolveInfo) List的动作,是因为List receivers &#x3D; null; 这个List没有指定是什么类型的，默认存放的是Object类型，所以静态动态被存放在了同一个里面。另外我们已经得到能够接收的列表，而且按照优先权来拍好了序，看来就只差最后一步了：分发。"></a>上面把动态广播的BroadcastFilter加入静态receivers(ResolveInfo) List的动作,是因为List receivers &#x3D; null; 这个List没有指定是什么类型的，默认存放的是Object类型，所以静态动态被存放在了同一个里面。另外我们已经得到能够接收的列表，而且按照优先权来拍好了序，看来就只差最后一步了：分发。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line">if ((receivers != null &amp;&amp; receivers.size() &gt; 0)</span><br><span class="line">        || resultTo != null) &#123;</span><br><span class="line">    //之前分析过，拿queue</span><br><span class="line">    BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line">    //这些准备分发的接收器信息封装在BroadcastRecord中</span><br><span class="line">    BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,</span><br><span class="line">            callerPackage, callingPid, callingUid, callerInstantApp, resolvedType,</span><br><span class="line">            requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode,</span><br><span class="line">            resultData, resultExtras, ordered, sticky, false, userId,</span><br><span class="line">            allowBackgroundActivityStarts, timeoutExempt);</span><br><span class="line">   //注意了，这里入的队是有序的</span><br><span class="line">        queue.enqueueOrderedBroadcastLocked(r);</span><br><span class="line">   //分发</span><br><span class="line">        queue.scheduleBroadcastsLocked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">public void enqueueOrderedBroadcastLocked(BroadcastRecord r) &#123;</span><br><span class="line">    mDispatcher.enqueueOrderedBroadcastLocked(r);</span><br><span class="line">    enqueueBroadcastHelper(r);</span><br><span class="line">&#125;</span><br><span class="line">void enqueueOrderedBroadcastLocked(BroadcastRecord r) &#123;</span><br><span class="line">// ArrayList&lt;BroadcastRecord&gt; mOrderedBroadcasts = new ArrayList&lt;&gt;();</span><br><span class="line">    mOrderedBroadcasts.add(r);</span><br><span class="line">&#125;</span><br><span class="line">//这个 queue.scheduleBroadcastsLocked();我们已经看过了，使用handler发个消息开始分发，然后</span><br><span class="line">final void processNextBroadcastLocked(boolean fromMsg, boolean skipOomAdj) &#123;</span><br><span class="line">    BroadcastRecord r;</span><br><span class="line">    while (mParallelBroadcasts.size() &gt; 0) &#123; //分发无序的广播</span><br><span class="line">    &#125;</span><br><span class="line">    do &#123;</span><br><span class="line">    // 获取一个又一个的BroadcastRecord </span><br><span class="line">    r = mDispatcher.getNextBroadcastLocked(now);</span><br><span class="line">    </span><br><span class="line">        &#125; while (r == null);</span><br><span class="line">    // Get the next receiver...</span><br><span class="line">   int recIdx = r.nextReceiver++;</span><br><span class="line">   final Object nextReceiver = r.receivers.get(recIdx);</span><br><span class="line">   if (nextReceiver instanceof BroadcastFilter) &#123; //动态广播</span><br><span class="line">        //分发，这里就不去分析这个动态广播的分发了，上面已经分析过了。</span><br><span class="line">        deliverToRegisteredReceiverLocked(r, filter, r.ordered, recIdx);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //静态广播的分发</span><br><span class="line">    ResolveInfo info =</span><br><span class="line">    (ResolveInfo)nextReceiver;</span><br><span class="line">    // 一系列的判断，判断要接收的apk是否有权限</span><br><span class="line">  // Is this receiver&#x27;s application already running?</span><br><span class="line">    if (app != null &amp;&amp; app.thread != null &amp;&amp; !app.killed) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            app.addPackage(info.activityInfo.packageName,</span><br><span class="line">                    info.activityInfo.applicationInfo.longVersionCode, mService.mProcessStats);</span><br><span class="line">            maybeAddAllowBackgroundActivityStartsToken(app, r);</span><br><span class="line">            processCurBroadcastLocked(r, app, skipOomAdj); //注意在这里</span><br><span class="line">            return;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    //startProcessLocked完成了app的启动，看下面这条注释，当app启动再去执行广播。</span><br><span class="line">    // Not running -- get it started, to be executed when the app comes up.</span><br><span class="line">    if ((r.curApp=mService.startProcessLocked(targetProcess,</span><br><span class="line">            info.activityInfo.applicationInfo, true,</span><br><span class="line">            r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND,</span><br><span class="line">            new HostingRecord(&quot;broadcast&quot;, r.curComponent),</span><br><span class="line">            (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) != 0, false, false))</span><br><span class="line">                    == null) &#123;</span><br><span class="line">        // Ah, this recipient is unavailable.  Finish it if necessary,</span><br><span class="line">        // and mark the broadcast record as ready for the next.</span><br><span class="line">        Slog.w(TAG, &quot;Unable to launch app &quot;</span><br><span class="line">                + info.activityInfo.applicationInfo.packageName + &quot;/&quot;</span><br><span class="line">                + receiverUid + &quot; for broadcast &quot;</span><br><span class="line">                + r.intent + &quot;: process is bad&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">   //结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分析上面的processCurBroadcastLocked，问题应该就在这里了："><a href="#分析上面的processCurBroadcastLocked，问题应该就在这里了：" class="headerlink" title="分析上面的processCurBroadcastLocked，问题应该就在这里了："></a>分析上面的processCurBroadcastLocked，问题应该就在这里了：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//多么熟悉的姿势</span><br><span class="line">app.thread.scheduleReceiver(new Intent(r.intent), r.curReceiver,</span><br><span class="line">        mService.compatibilityInfoForPackage(r.curReceiver.applicationInfo),</span><br><span class="line">        r.resultCode, r.resultData, r.resultExtras, r.ordered, r.userId,</span><br><span class="line">        app.getReportedProcState());</span><br><span class="line">//接着进入ApplicationThread中</span><br><span class="line">public final void scheduleReceiver(Intent intent, ActivityInfo info,</span><br><span class="line">        CompatibilityInfo compatInfo, int resultCode, String data, Bundle extras,</span><br><span class="line">        boolean sync, int sendingUser, int processState) &#123;</span><br><span class="line">    updateProcessState(processState, false);</span><br><span class="line">    ReceiverData r = new ReceiverData(intent, resultCode, data, extras,</span><br><span class="line">            sync, false, mAppThread.asBinder(), sendingUser);</span><br><span class="line">    r.info = info;</span><br><span class="line">    r.compatInfo = compatInfo;</span><br><span class="line">    sendMessage(H.RECEIVER, r); //使用mH去发送这个广播接收的消息</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)</span><br><span class="line">private void handleReceiver(ReceiverData data) &#123;</span><br><span class="line">    IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">    Application app;</span><br><span class="line">    BroadcastReceiver receiver;</span><br><span class="line">    ContextImpl context;</span><br><span class="line">    try &#123;</span><br><span class="line">        app = packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line">        context = (ContextImpl) app.getBaseContext();</span><br><span class="line">        //类加载器也安排上了，看来是要搞事情了</span><br><span class="line">        java.lang.ClassLoader cl = context.getClassLoader();</span><br><span class="line">        //下面这个instantiateReceiver，代码是(BroadcastReceiver) cl.loadClass(className).newInstance();</span><br><span class="line">        //果然，反射加载了我们的静态广播接收器</span><br><span class="line">        receiver = packageInfo.getAppFactory()</span><br><span class="line">                .instantiateReceiver(cl, data.info.name, data.intent);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        receiver.setPendingResult(data);</span><br><span class="line">        //一个轻快的函数调用，至此进入onReceiver方法，收到消息。</span><br><span class="line">        receiver.onReceive(context.getReceiverRestrictedContext(),</span><br><span class="line">                data.intent);</span><br><span class="line">    &#125;</span><br><span class="line">    if (receiver.getPendingResult() != null) &#123;</span><br><span class="line">        data.finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="上面还遗留一个问题就是：要是app没有启动，那么这个广播是怎么分发的？"><a href="#上面还遗留一个问题就是：要是app没有启动，那么这个广播是怎么分发的？" class="headerlink" title="上面还遗留一个问题就是：要是app没有启动，那么这个广播是怎么分发的？"></a>上面还遗留一个问题就是：要是app没有启动，那么这个广播是怎么分发的？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">//mService.startProcessLocked(...)  这个是AMS</span><br><span class="line">mProcessList.startProcessLocked(...)</span><br><span class="line"></span><br><span class="line">final ProcessRecord startProcessLocked(String processName, ApplicationInfo info,</span><br><span class="line">        boolean knownToBeDead, int intentFlags, HostingRecord hostingRecord,</span><br><span class="line">        boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge,</span><br><span class="line">        String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler) &#123;</span><br><span class="line">    long startTime = SystemClock.elapsedRealtime();</span><br><span class="line">    ProcessRecord app;</span><br><span class="line">    if (!isolated) &#123;</span><br><span class="line">        //app没有启动，所以这里的app是null</span><br><span class="line">        app = getProcessRecordLocked(processName, info.uid, keepIfLarge);</span><br><span class="line">    &#125;</span><br><span class="line">if (app == null) &#123;</span><br><span class="line">    //注意这里，构建ProcessRecord</span><br><span class="line">    app = newProcessRecordLocked(info, processName, isolated, isolatedUid, hostingRecord);</span><br><span class="line">    app.crashHandler = crashHandler;</span><br><span class="line">&#125; </span><br><span class="line">//注意这里,启动Process</span><br><span class="line">final boolean success = startProcessLocked(app, hostingRecord, abiOverride);</span><br><span class="line">&#125;</span><br><span class="line">//分析构建Process</span><br><span class="line">final ProcessRecord newProcessRecordLocked(ApplicationInfo info, String customProcess,</span><br><span class="line">        boolean isolated, int isolatedUid, HostingRecord hostingRecord) &#123;</span><br><span class="line">        final ProcessRecord r = new ProcessRecord(mService, info, proc, uid);</span><br><span class="line">        addProcessNameLocked(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final void addProcessNameLocked(ProcessRecord proc) &#123;</span><br><span class="line">    mProcessNames.put(proc.processName, proc.uid, proc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//启动Process</span><br><span class="line">final boolean startProcessLocked(ProcessRecord app, HostingRecord hostingRecord,</span><br><span class="line">        String abiOverride) &#123;</span><br><span class="line">    return startProcessLocked(app, hostingRecord,</span><br><span class="line">            false /* disableHiddenApiChecks */, false /* mountExtStorageFull */, abiOverride);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boolean startProcessLocked(HostingRecord hostingRecord,</span><br><span class="line">        String entryPoint,</span><br><span class="line">        ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal,</span><br><span class="line">        String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span><br><span class="line">        long startTime) &#123;</span><br><span class="line">final Process.ProcessStartResult startResult = startProcess(hostingRecord,</span><br><span class="line">        entryPoint, app,</span><br><span class="line">        uid, gids, runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet,</span><br><span class="line">        invokeWith, startTime);</span><br><span class="line">handleProcessStartedLocked(app, startResult.pid, startResult.usingWrapper,</span><br><span class="line">        startSeq, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Process.ProcessStartResult startProcess(HostingRecord hostingRecord, String entryPoint,</span><br><span class="line">        ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal,</span><br><span class="line">        String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span><br><span class="line">        long startTime) &#123;</span><br><span class="line">final Process.ProcessStartResult startResult;</span><br><span class="line">if (hostingRecord.usesWebviewZygote()) &#123;  //启动WebView</span><br><span class="line">    startResult = startWebView(entryPoint,</span><br><span class="line">            app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">            app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">            app.info.dataDir, null, app.info.packageName,</span><br><span class="line">            new String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">&#125; else if (hostingRecord.usesAppZygote()) &#123; //应用程序的Zygote</span><br><span class="line">    final AppZygote appZygote = createAppZygoteForProcessIfNeeded(app);</span><br><span class="line">    startResult = appZygote.getProcess().start(entryPoint,</span><br><span class="line">            app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">            app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">            app.info.dataDir, null, app.info.packageName,</span><br><span class="line">            /*useUsapPool=*/ false,</span><br><span class="line">            new String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">//走这</span><br><span class="line">    startResult = Process.start(entryPoint,</span><br><span class="line">            app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">            app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">            app.info.dataDir, invokeWith, app.info.packageName,</span><br><span class="line">            new String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">&#125;</span><br><span class="line">checkSlow(startTime, &quot;startProcess: returned from zygote!&quot;);</span><br><span class="line">return startResult;</span><br><span class="line">&#125;</span><br><span class="line">#Process.java</span><br><span class="line">public static ProcessStartResult start(@NonNull final String processClass,</span><br><span class="line">                                       @Nullable final String niceName,</span><br><span class="line">                                       int uid, int gid, @Nullable int[] gids,</span><br><span class="line">                                       int runtimeFlags,</span><br><span class="line">                                       int mountExternal,</span><br><span class="line">                                       int targetSdkVersion,</span><br><span class="line">                                       @Nullable String seInfo,</span><br><span class="line">                                       @NonNull String abi,</span><br><span class="line">                                       @Nullable String instructionSet,</span><br><span class="line">                                       @Nullable String appDataDir,</span><br><span class="line">                                       @Nullable String invokeWith,</span><br><span class="line">                                       @Nullable String packageName,</span><br><span class="line">                                       @Nullable String[] zygoteArgs) &#123;</span><br><span class="line">    //这个类型 ZygoteProcess ZYGOTE_PROCESS = new ZygoteProcess();</span><br><span class="line">    return ZYGOTE_PROCESS.start(processClass, niceName, uid, gid, gids,</span><br><span class="line">                runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                abi, instructionSet, appDataDir, invokeWith, packageName,</span><br><span class="line">                /*useUsapPool=*/ true, zygoteArgs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">        runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">        abi, instructionSet, appDataDir, invokeWith, /*startChildZygote=*/ false,</span><br><span class="line">        packageName, useUsapPool, zygoteArgs);</span><br><span class="line">//最后调用到</span><br><span class="line">private Process.ProcessStartResult attemptZygoteSendArgsAndGetResult(</span><br><span class="line">        ZygoteState zygoteState, String msgStr) throws ZygoteStartFailedEx &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        final BufferedWriter zygoteWriter = zygoteState.mZygoteOutputWriter;</span><br><span class="line">        final DataInputStream zygoteInputStream = zygoteState.mZygoteInputStream;</span><br><span class="line"></span><br><span class="line">        zygoteWriter.write(msgStr); //写入数据 ，其实我们知道这个就是通过Socket给zygote发送消息，让他fork一个新的进程，由此一个app产生！</span><br><span class="line">        zygoteWriter.flush(); //刷新缓冲区</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125; catch (IOException ex) &#123;</span><br><span class="line">        zygoteState.close();</span><br><span class="line">        Log.e(LOG_TAG, &quot;IO Exception while communicating with Zygote - &quot;</span><br><span class="line">                + ex.toString());</span><br><span class="line">        throw new ZygoteStartFailedEx(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花."></a>完结撒花.</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/24/20250324/" data-id="cmdmr0kna0001zsu14nv8hhjz" data-title="Android源码阅读之———广播的注册与分发" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/08/20/C-C-%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%B8%80/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          C/C++基础之一
        
      </div>
    </a>
  
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/08/">August 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/08/20/C-C-%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%B8%80/">C/C++基础之一</a>
          </li>
        
          <li>
            <a href="/2025/03/24/20250324/">Android源码阅读之———广播的注册与分发</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 Cherry<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>