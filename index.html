<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>出发的越久,也要记得当初的目的</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="疯一样的男子">
<meta property="og:type" content="website">
<meta property="og:title" content="出发的越久,也要记得当初的目的">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="出发的越久,也要记得当初的目的">
<meta property="og:description" content="疯一样的男子">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Cherry">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="出发的越久,也要记得当初的目的" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">出发的越久,也要记得当初的目的</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">加油,努力</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-C-C-基础之二" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/21/C-C-%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%8C/" class="article-date">
  <time class="dt-published" datetime="2025-08-21T06:01:38.000Z" itemprop="datePublished">2025-08-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/21/C-C-%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%8C/">C/C++基础之二(类的构造函数)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="C-C-基础之二-类的构造函数"><a href="#C-C-基础之二-类的构造函数" class="headerlink" title="C&#x2F;C++基础之二(类的构造函数)"></a>C&#x2F;C++基础之二(类的构造函数)</h3><h4 id="Talk-is-cheap-Show-me-the-code"><a href="#Talk-is-cheap-Show-me-the-code" class="headerlink" title="Talk is cheap. Show me the code."></a>Talk is cheap. Show me the code.</h4><h5 id="1-构造函数-有参，无参？"><a href="#1-构造函数-有参，无参？" class="headerlink" title="1. 构造函数,有参，无参？"></a>1. 构造函数,有参，无参？</h5><h5 id="2-析构函数的调用时机？"><a href="#2-析构函数的调用时机？" class="headerlink" title="2. 析构函数的调用时机？"></a>2. 析构函数的调用时机？</h5><h5 id="3-如何在构造函数中初始化某个成员类？"><a href="#3-如何在构造函数中初始化某个成员类？" class="headerlink" title="3. 如何在构造函数中初始化某个成员类？"></a>3. 如何在构造函数中初始化某个成员类？</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">char</span> *work;</span><br><span class="line">    <span class="type">char</span> *sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>();</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">char</span> *name,<span class="type">char</span> *work,<span class="type">int</span> age,<span class="type">char</span> *sex=(<span class="type">char</span> *)<span class="string">&quot;f&quot;</span>);</span><br><span class="line">    ~<span class="built_in">Person</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">char</span> *name)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//无参构造函数</span></span><br><span class="line">Person::<span class="built_in">Person</span>(<span class="comment">/* args */</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Person()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 对指针变量赋初值很重要，否则是野指针，直接访问非常危险,会有问题的</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;work = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;sex = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person::<span class="built_in">Person</span>(<span class="type">char</span> *name,<span class="type">char</span> *work,<span class="type">int</span> age,<span class="type">char</span> *sex)</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// 下面变量共享内存的写法，也叫做浅拷贝，如果外部被释放，那么这里就成了野指针。很危险</span></span><br><span class="line">    <span class="comment">// this-&gt;name = name;</span></span><br><span class="line">    <span class="comment">// this-&gt;work = work;</span></span><br><span class="line">    <span class="comment">// 分配内存，也叫做深拷贝，安全，但要记得自己释放new出来的内存，释放交给析构函数</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;name = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(name)<span class="number">+1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name,name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;work = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(work)<span class="number">+1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;work,work);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>-&gt;sex = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(sex)<span class="number">+1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;sex,sex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Person(char *name,char *work,int age)&quot;</span> &lt;&lt; <span class="string">&quot;,name:&quot;</span>&lt;&lt; name &lt;&lt; <span class="string">&quot;,work:&quot;</span>&lt;&lt; work &lt;&lt;<span class="string">&quot;,age:&quot;</span>&lt;&lt; age &lt;&lt;<span class="string">&quot;,sex:&quot;</span>&lt;&lt; sex &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::printInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;name:&quot;</span>&lt;&lt; name &lt;&lt; <span class="string">&quot;,work:&quot;</span>&lt;&lt; work &lt;&lt;<span class="string">&quot;,age:&quot;</span>&lt;&lt; age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">Person::~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~Person(),name:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;name)</span><br><span class="line">    &#123;   </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;delete name:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; endl;</span><br><span class="line">       <span class="comment">// C++ 要严格遵守 new ↔ delete，new[] ↔ delete[]。</span></span><br><span class="line">       <span class="comment">// delete this-&gt;name;</span></span><br><span class="line">        <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;work)</span><br><span class="line">    &#123;   </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;delete work:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;work &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// C++ 要严格遵守 new ↔ delete，new[] ↔ delete[]。</span></span><br><span class="line">        <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;work;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;sex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// C++ 要严格遵守 new ↔ delete，new[] ↔ delete[]。</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;delete sex:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;sex &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Person father;</span><br><span class="line">    Person mother;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Student()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造函数中完成成员变量的初始化,成员变量的初始化和:father(...),mother(...)无关，之和上面的成员定义顺序有关</span></span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">char</span> *fatherName,<span class="type">char</span> *motherName,<span class="type">int</span> id):<span class="built_in">father</span>(fatherName,<span class="string">&quot;CFO&quot;</span>,<span class="number">28</span>,(<span class="type">char</span> *)<span class="string">&quot;M&quot;</span>),<span class="built_in">mother</span>(motherName,<span class="string">&quot;BOSS&quot;</span>,<span class="number">18</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Student</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~Student()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">person_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person *p = <span class="keyword">new</span> <span class="built_in">Person</span>(<span class="string">&quot;lisi&quot;</span>,<span class="string">&quot;student&quot;</span>,<span class="number">18</span>);</span><br><span class="line">    <span class="comment">//new出来的内存一定要释放掉，否则它是不会释放的</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person per;</span><br><span class="line">    <span class="comment">//注意下面这行代码并没有创建per1对象，只是一个方法声明，类似 int sum(); </span></span><br><span class="line">    <span class="function">Person <span class="title">per1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 调用有参数的构造函数，最后一个sex参数使用默认值</span></span><br><span class="line">    <span class="function">Person <span class="title">per2</span><span class="params">(<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;laywer&quot;</span>,<span class="number">48</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">per3</span><span class="params">(<span class="string">&quot;wangwu&quot;</span>,<span class="string">&quot;CEO&quot;</span>,<span class="number">29</span>,<span class="string">&quot;M&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">person_test</span>();</span><br><span class="line">    <span class="function">Student <span class="title">s</span><span class="params">(<span class="string">&quot;Jack&quot;</span>,<span class="string">&quot;Alice&quot;</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>输出如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Person()</span><br><span class="line">Person(char *name,char *work,int age),name:zhangsan,work:laywer,age:48,sex:f</span><br><span class="line">Person(char *name,char *work,int age),name:wangwu,work:CEO,age:29,sex:M</span><br><span class="line">Person(char *name,char *work,int age),name:lisi,work:student,age:18,sex:f</span><br><span class="line">~Person(),name:lisi</span><br><span class="line">delete name:lisi</span><br><span class="line">delete work:student</span><br><span class="line">delete sex:f</span><br><span class="line">Person(char *name,char *work,int age),name:Jack,work:CFO,age:28,sex:M</span><br><span class="line">Person(char *name,char *work,int age),name:Alice,work:BOSS,age:18,sex:f</span><br><span class="line">~Student()</span><br><span class="line">~Person(),name:Alice</span><br><span class="line">delete name:Alice</span><br><span class="line">delete work:BOSS</span><br><span class="line">delete sex:f</span><br><span class="line">~Person(),name:Jack</span><br><span class="line">delete name:Jack</span><br><span class="line">delete work:CFO</span><br><span class="line">delete sex:M</span><br><span class="line">~Person(),name:wangwu</span><br><span class="line">delete name:wangwu</span><br><span class="line">delete work:CEO</span><br><span class="line">delete sex:M</span><br><span class="line">~Person(),name:zhangsan</span><br><span class="line">delete name:zhangsan</span><br><span class="line">delete work:laywer</span><br><span class="line">delete sex:f</span><br><span class="line">~Person(),name:</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/21/C-C-%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%8C/" data-id="cmekzw6r4000070u1h2ct8tmp" data-title="C/C++基础之二(类的构造函数)" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-C-C-基础之一" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/20/C-C-%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%B8%80/" class="article-date">
  <time class="dt-published" datetime="2025-08-20T06:08:37.000Z" itemprop="datePublished">2025-08-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/20/C-C-%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%B8%80/">C/C++基础之一</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="C-C-基础之一-数据类型、数组、指针、结构体"><a href="#C-C-基础之一-数据类型、数组、指针、结构体" class="headerlink" title="C&#x2F;C++基础之一(数据类型、数组、指针、结构体)"></a>C&#x2F;C++基础之一(数据类型、数组、指针、结构体)</h3><h4 id="Talk-is-cheap-Show-me-the-code"><a href="#Talk-is-cheap-Show-me-the-code" class="headerlink" title="Talk is cheap. Show me the code."></a>Talk is cheap. Show me the code.</h4><ul>
<li>结构体定义</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TYPEDEFINE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPEDEFINE_H</span></span><br><span class="line"><span class="comment">//枚举的使用</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span></span><br><span class="line">    RED = <span class="number">0</span>,</span><br><span class="line">    YELLOW = <span class="number">1</span>,</span><br><span class="line">    GREEN = <span class="number">2</span></span><br><span class="line">&#125;TrafficLight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span></span><br><span class="line">    START,</span><br><span class="line">    RUNNING,</span><br><span class="line">    SUSPEND,</span><br><span class="line">    STOP,</span><br><span class="line">    DESTORY</span><br><span class="line">&#125;Mission;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> sex;</span><br><span class="line">    <span class="type">char</span> lastName[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> firstName[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>main函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testDatatype</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;数据类型:\n&quot;</span>);</span><br><span class="line">  <span class="type">int</span> intValue = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;整型%d\n&quot;</span>,intValue);</span><br><span class="line">  <span class="type">char</span> charValue = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;char类型:%c\n&quot;</span>,charValue);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> uintValue = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;无符号整型:%d\n&quot;</span>,uintValue);</span><br><span class="line">  <span class="type">float</span> fValue = <span class="number">3.14</span>;</span><br><span class="line">  <span class="type">double</span> dValue = <span class="number">3.14</span>;</span><br><span class="line">  <span class="comment">//long 是4 byte, long long是8字节</span></span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> lValue = <span class="number">123456789</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;float类型:%.2f\n&quot;</span>,fValue);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;double类型%f\n&quot;</span>,dValue);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;long类型:%ld\n&quot;</span>,lValue);</span><br><span class="line">  <span class="comment">//除此之外还有一些无符号整型的类型 ,无符号第一位不表示正负符号，只存在正数，因此比有符号的正数大一倍。</span></span><br><span class="line">  <span class="comment">//unsigned int</span></span><br><span class="line">  <span class="comment">//unsigned short</span></span><br><span class="line">  <span class="comment">//unsigned char</span></span><br><span class="line">  <span class="comment">//unsigned long</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">testPointer</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *p = &amp;a;</span><br><span class="line">    <span class="type">int</span> **pp = &amp;p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a value:%d\n,a address is:%p\n&quot;</span>,a,&amp;a);</span><br><span class="line">    <span class="comment">// &amp;p  p这个int指针自身的内存地址</span></span><br><span class="line">    <span class="comment">//p    p指针存放的地址值，</span></span><br><span class="line">    <span class="comment">//*p  解引用，得到p指针存放的地址值所指向的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p memroy address is:%p,p point address is%p, p point value is:%d\n&quot;</span>,&amp;p,p,*p);</span><br><span class="line">    <span class="comment">// pp 是pp指针的值， &amp;pp是指针的内存地址， **pp是两次解引用，得到p指针所指向的值</span></span><br><span class="line">    <span class="comment">// *pp 一次解引用，得到p的值,也就是a的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*pp is%p, pp memroy address is:%p,pp point address value is:%p\n, pp value:%d\n&quot;</span>,*pp, &amp;pp, pp,**pp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> s = <span class="number">1024</span>;</span><br><span class="line">    <span class="type">int</span> *sP = &amp;s;</span><br><span class="line">    <span class="comment">// 发生了隐式转换  &#x27;b&#x27; == 98</span></span><br><span class="line">    *sP = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s origin address:%p\n&quot;</span>,&amp;s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sp point address:%p\n&quot;</span>,&amp;sP);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sP point target address:%p\n&quot;</span>,sP);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sP point target vakye:%c\n&quot;</span>,*sP);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;point sieze:%d\n&quot;</span>,<span class="keyword">sizeof</span>(*sP));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> arrayA[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *pA = arrayA;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pA is :%d\n&quot;</span>,*(pA+<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> arrayB[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> (*arrayBP)[<span class="number">3</span>] = arrayB;</span><br><span class="line">    <span class="comment">//int (*p)[3] 是指针，指向“每行 3 个元素”的数组。</span></span><br><span class="line">    <span class="type">int</span> (*pC)[<span class="number">3</span>] = arrayB;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arrayBP[0][2]%d\n&quot;</span>,arrayBP[<span class="number">0</span>][<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(*(*(pC+<span class="number">1</span>)+<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">testCalculate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testArray</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//数组测试,数组在创建的时候必须指明容量，不要越界访问</span></span><br><span class="line">  <span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line">  <span class="type">int</span> b[<span class="number">10</span>]; </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    b[i] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 二维数组</span></span><br><span class="line">  <span class="type">int</span> c[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> str[] =<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  <span class="comment">// 得到的这个长度是6，多了一个\0</span></span><br><span class="line">  <span class="type">int</span> charArrayLength = <span class="keyword">sizeof</span>(str)/<span class="keyword">sizeof</span>(str[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,charArrayLength); </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(str));</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;charArrayLength;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,str[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">reverseChars</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//1.当前的字符串长度,下面这个写法是错误的，因为sizeof(s) 是指针的长度，指针的长度是4 byte</span></span><br><span class="line">  <span class="comment">// int length = sizeof(s)/sizeof(s[0]);</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;the length is %d&quot;</span>,length);</span><br><span class="line">  <span class="comment">//2.创建存储结果的字符串数组</span></span><br><span class="line">  <span class="type">char</span> *targetResult = (<span class="type">char</span> *)<span class="built_in">malloc</span>((length+<span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">  <span class="keyword">if</span> (targetResult == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//3.for倒叙循环获取字符，存入数组</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    targetResult[i] = s[length<span class="number">-1</span>-i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  targetResult[length] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  <span class="comment">//4.返回结果</span></span><br><span class="line">  <span class="keyword">return</span> targetResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;   </span><br><span class="line">    testDatatype();</span><br><span class="line">    testPointer();</span><br><span class="line">    <span class="comment">//测试指针函数,指针函数作为一个变量可以在函数间传递，方便的进行回调，使得程序更加灵活。</span></span><br><span class="line">    <span class="type">int</span> (*pSumFunc)(<span class="type">int</span>,<span class="type">int</span>) = testCalculate;</span><br><span class="line">    <span class="type">int</span> result = pSumFunc(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sum is:%d\n&quot;</span>,result);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;value is:%d \n&quot;</span>,calculateSub(i*i,i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//test enum</span></span><br><span class="line">    TrafficLight currentLight = YELLOW;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;current light is:%d&quot;</span>,currentLight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// struct Student student;</span></span><br><span class="line">    <span class="comment">// student.age = 15;</span></span><br><span class="line">    <span class="comment">// student.sex = 1;</span></span><br><span class="line">    <span class="comment">// lastName是char[10], c语言中数组不能整体赋值, 所以下面的赋值是错误的</span></span><br><span class="line">    <span class="comment">// student.lastName = &#123;&#x27;x&#x27;,&#x27;y&#x27;,&#x27;z&#x27;&#125;;</span></span><br><span class="line">    <span class="comment">// student.firstName = &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;&#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面是结构体的几种赋值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">student</span> =</span> &#123;<span class="number">15</span>,<span class="number">1</span>,<span class="string">&quot;y&quot;</span>,<span class="string">&quot;p&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">//使用strcpy赋值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">student2</span>;</span></span><br><span class="line">    <span class="built_in">strcpy</span>(student2.firstName,<span class="string">&quot;p&quot;</span>);</span><br><span class="line">    <span class="comment">//或者如下</span></span><br><span class="line">    student2.lastName[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    student2.lastName[<span class="number">1</span>] = <span class="string">&#x27;h&#x27;</span>;</span><br><span class="line">    student2.lastName[<span class="number">2</span>] = <span class="string">&#x27;e&#x27;</span>; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>,student.firstName,student.lastName);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>,student2.firstName,student2.lastName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串反转</span></span><br><span class="line">    <span class="type">char</span> *sArray = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">    <span class="comment">//获取长度这里问题就来了，如果使用sizeof(s) / sizeof(s[0]); 这种获取的是包含结尾\0的</span></span><br><span class="line">    <span class="comment">//如果通过strlen(s); 那么是不包含\0的</span></span><br><span class="line">    <span class="keyword">if</span> ((sArray!=<span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//下面计算长度这个写法是错误的</span></span><br><span class="line">        <span class="comment">//数组 → 可以用 sizeof 计算长度</span></span><br><span class="line">        <span class="comment">// 指针 → 必须用 strlen(s) 来计算字符串长度</span></span><br><span class="line">     <span class="comment">//   int sLength = sizeof(sArray)/sizeof(sArray[0]) - 1; // -1移除\0</span></span><br><span class="line">        <span class="type">int</span> sLength = <span class="built_in">strlen</span>(sArray);</span><br><span class="line">        <span class="type">char</span> *sResult = reverseChars(sArray,sLength);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;倒叙结果:%s\n&quot;</span>,sResult);</span><br><span class="line">        <span class="built_in">free</span>(sResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/20/C-C-%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%B8%80/" data-id="cmejkoz6q00008ku1f9f3gys6" data-title="C/C++基础之一" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-20250324" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/24/20250324/" class="article-date">
  <time class="dt-published" datetime="2025-03-24T07:37:00.000Z" itemprop="datePublished">2025-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/24/20250324/">Android源码阅读之———广播的注册与分发</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="这一节去分析一下广播的注册，广播消息的分发过程。"><a href="#这一节去分析一下广播的注册，广播消息的分发过程。" class="headerlink" title="这一节去分析一下广播的注册，广播消息的分发过程。"></a>这一节去分析一下广播的注册，广播消息的分发过程。</h4><hr>
<h5 id="一些概念："><a href="#一些概念：" class="headerlink" title="一些概念："></a>一些概念：</h5><ol>
<li>无序广播：默认发送的就是无序广播，所有注册了的广播几乎在同一时刻接收到广播消息；</li>
<li>有序广播：优先级越高越先收到，传递过程中，可以控制结束该广播，也可以修改传递数据；</li>
<li>粘性消息：发送的粘性消息一直存放在AMS中，当注册广播时，如果之前已经有粘性消息存在，则直接派发。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#ContextImpl$registerReceiver</span><br><span class="line">private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId,</span><br><span class="line">        IntentFilter filter, String broadcastPermission,</span><br><span class="line">        Handler scheduler, Context context, int flags) &#123; </span><br><span class="line">    //注意这个IIntentReceiver，看名字就知道是个接口。在AndroidStudio中找不到。一搜索，咦，这是个aidl文件。</span><br><span class="line">    //我们知道这个IIntentReceiver用于Binder通信，且在此是作为服务端。</span><br><span class="line">    IIntentReceiver rd = null;</span><br><span class="line">    if (receiver != null) &#123;</span><br><span class="line">        if (mPackageInfo != null &amp;&amp; context != null) &#123;</span><br><span class="line">            if (scheduler == null) &#123;</span><br><span class="line">                //ActivityThread中的mH，是一个Handler</span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">       (1)   //mPackageInfo是LoaderApk类型，其中创建了ReceiverDispatcher，这个类内部有一个</span><br><span class="line">            // InnerReceiver extends IIntentReceiver.Stub 这个InnerReceiver继承了IIntentReceiver.Stub</span><br><span class="line">            // rd 作为服务端，用于接收广播接收</span><br><span class="line">            rd = mPackageInfo.getReceiverDispatcher(</span><br><span class="line">                receiver, context, scheduler,</span><br><span class="line">                mMainThread.getInstrumentation(), true);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (scheduler == null) &#123;</span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            rd = new LoadedApk.ReceiverDispatcher(</span><br><span class="line">                    receiver, context, scheduler, null, true).getIIntentReceiver();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        //注意此处有一个Intent的返回，另外传入的参数有ApplicationThread和IIntentReceiver和IntentFilter</span><br><span class="line">        final Intent intent = ActivityManager.getService().registerReceiver(</span><br><span class="line">                mMainThread.getApplicationThread(), mBasePackageName, rd, filter,</span><br><span class="line">                broadcastPermission, userId, flags);</span><br><span class="line">        if (intent != null) &#123;</span><br><span class="line">            intent.setExtrasClassLoader(getClassLoader());</span><br><span class="line">            intent.prepareToEnterProcess();</span><br><span class="line">        &#125;</span><br><span class="line">        return intent; //把intent返回回去</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-上面获取IIntentReceiver这个binder的时候，涉及到了LoadedApk这个类，内部有一个ReceiverDispatcher的内部类，ReceiverDispatcher这个类的内部有一个InnerReceiver实现了IIntentReceiver-Stub-具有了跨进程通信功能。也就是说接收然后分发广播，这个动作会在LoadedApk的InnerReceiver。那么我们看一下数据LoadedApk中的数据结构："><a href="#1-上面获取IIntentReceiver这个binder的时候，涉及到了LoadedApk这个类，内部有一个ReceiverDispatcher的内部类，ReceiverDispatcher这个类的内部有一个InnerReceiver实现了IIntentReceiver-Stub-具有了跨进程通信功能。也就是说接收然后分发广播，这个动作会在LoadedApk的InnerReceiver。那么我们看一下数据LoadedApk中的数据结构：" class="headerlink" title="(1)  上面获取IIntentReceiver这个binder的时候，涉及到了LoadedApk这个类，内部有一个ReceiverDispatcher的内部类，ReceiverDispatcher这个类的内部有一个InnerReceiver实现了IIntentReceiver.Stub,具有了跨进程通信功能。也就是说接收然后分发广播，这个动作会在LoadedApk的InnerReceiver。那么我们看一下数据LoadedApk中的数据结构："></a>(1)  上面获取IIntentReceiver这个binder的时候，涉及到了LoadedApk这个类，内部有一个ReceiverDispatcher的内部类，ReceiverDispatcher这个类的内部有一个InnerReceiver实现了IIntentReceiver.Stub,具有了跨进程通信功能。也就是说接收然后分发广播，这个动作会在LoadedApk的InnerReceiver。那么我们看一下数据LoadedApk中的数据结构：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//LoadedApk的全局变量</span><br><span class="line">//context上下文作为key,value也是一个Map，这个Map是以BroadcastReceiver位key, ReceiverDispatcher为value</span><br><span class="line">private final ArrayMap&lt;Context, ArrayMap&lt;BroadcastReceiver, ReceiverDispatcher&gt;&gt; mReceivers</span><br><span class="line">    = new ArrayMap&lt;&gt;();</span><br><span class="line">private final ArrayMap&lt;Context, ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;&gt; mUnregisteredReceivers</span><br><span class="line">    = new ArrayMap&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h4 id="困难九十九，难不倒两只手。进入AMS，查看registerReceiver"><a href="#困难九十九，难不倒两只手。进入AMS，查看registerReceiver" class="headerlink" title="困难九十九，难不倒两只手。进入AMS，查看registerReceiver"></a>困难九十九，难不倒两只手。进入AMS，查看registerReceiver</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">#ActivityManagerService.java$registerReceiver</span><br><span class="line">//传入的参数第一个是：IApplicationThread，后面还有一个IIntentReceiver，都具有RPC能力。</span><br><span class="line">public Intent registerReceiver(IApplicationThread caller, String callerPackage,</span><br><span class="line">        IIntentReceiver receiver, IntentFilter filter, String permission, int userId,</span><br><span class="line">        int flags) &#123;</span><br><span class="line">    ArrayList&lt;Intent&gt; stickyIntents = null;//一个粘性意图的列表悄然出现</span><br><span class="line">    ProcessRecord callerApp = null;//似乎是记录进程的一个类</span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        if (caller != null) &#123;</span><br><span class="line">           //根据IApplicationThread这个Binder去寻找ProcessRecord,这个类，似乎管控着所有启动的Application</span><br><span class="line">           //另外还有一点，就是这个IApplicationThread是在ActivityThread中初始化的，ActivityThread又属于app入口点，所以一个app进程只有一个IApplicationThread</span><br><span class="line">            callerApp = getRecordForAppLocked(caller); </span><br><span class="line">        &#125; </span><br><span class="line">        //取出本次要注册广播的Action，准备进行迭代</span><br><span class="line">        Iterator&lt;String&gt; actions = filter.actionsIterator();</span><br><span class="line">        if (actions == null) &#123;</span><br><span class="line">            ArrayList&lt;String&gt; noAction = new ArrayList&lt;String&gt;(1);</span><br><span class="line">            noAction.add(null);</span><br><span class="line">            actions = noAction.iterator();</span><br><span class="line">        &#125;</span><br><span class="line">        // Collect stickies of users</span><br><span class="line">        int[] userIds = &#123; UserHandle.USER_ALL, UserHandle.getUserId(callingUid) &#125;;</span><br><span class="line">        while (actions.hasNext()) &#123;</span><br><span class="line">            String action = actions.next();//遍历action</span><br><span class="line">            for (int id : userIds) &#123;</span><br><span class="line">//mStickyBroadcasts类型是SparseArray&lt;ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt;&gt;，SparseArray映射一个Integer到一个Object</span><br><span class="line">                ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(id);</span><br><span class="line">                if (stickies != null) &#123;</span><br><span class="line">                    ArrayList&lt;Intent&gt; intents = stickies.get(action);</span><br><span class="line">                    if (intents != null) &#123;</span><br><span class="line">                        if (stickyIntents == null) &#123;</span><br><span class="line">                            stickyIntents = new ArrayList&lt;Intent&gt;();</span><br><span class="line">                        &#125;</span><br><span class="line">                        //根据本次的action找到粘性事件的Intent</span><br><span class="line">                        stickyIntents.addAll(intents);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Intent&gt; allSticky = null;</span><br><span class="line">    if (stickyIntents != null) &#123;</span><br><span class="line">        final ContentResolver resolver = mContext.getContentResolver();</span><br><span class="line">        // Look for any matching sticky broadcasts...</span><br><span class="line">        for (int i = 0, N = stickyIntents.size(); i &lt; N; i++) &#123;</span><br><span class="line">            Intent intent = stickyIntents.get(i);</span><br><span class="line">            //我正在注册广播接收器，你问我是否和AMS中存在的粘性广播匹配。</span><br><span class="line">            //那是啥子意思嘛？很明显，就是你注册的这个广播接收器，怕是想接收已经存在的粘性事件。</span><br><span class="line">            if (filter.match(resolver, intent, true, TAG) &gt;= 0) &#123;</span><br><span class="line">                if (allSticky == null) &#123;</span><br><span class="line">                    allSticky = new ArrayList&lt;Intent&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                //匹配加入进来，是否这些粘性intent就是要分发给正在注册的这个广播了？我们按照着剧本往下走。</span><br><span class="line">                allSticky.add(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // The first sticky in the list is returned directly back to the client.</span><br><span class="line">    Intent sticky = allSticky != null ? allSticky.get(0) : null; //确实有粘性事件的Intent匹配当前要注册的Fliter，那么返回第一个,要么是NUll！</span><br><span class="line">    if (receiver == null) &#123;</span><br><span class="line">//也就是我们可以通过registerBoradCastReceiver(null,IntentFliter(action))，根据返回判定是否存在粘性广播</span><br><span class="line">        return sticky;  //intent = registerBoradCastReceiver(null,IntentFliter(action)),这种方式注册的广播，已经拿到了他想要的粘性事件结果Intent，剧本结束。</span><br><span class="line">    &#125;</span><br><span class="line">    //剧本走到这里，有可能这次注册，监听的Action的确是粘性事件，但是他有传入receiver</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        //HashMap&lt;IBinder, ReceiverList&gt;  mRegisteredReceivers，键是IIntentReceiver</span><br><span class="line">        //receiver是IIntentReceiver,这个东西和Context一一对应，也就是Activity, 也就是这边AMS这里一个ReceiverList包含了一个Activity里所有注册了的广播。</span><br><span class="line">        ReceiverList rl = mRegisteredReceivers.get(receiver.asBinder()); </span><br><span class="line">        if (rl == null) &#123;</span><br><span class="line">            rl = new ReceiverList(this, callerApp, callingPid, callingUid,</span><br><span class="line">                    userId, receiver);</span><br><span class="line">            if (rl.app != null) &#123;</span><br><span class="line">                // rl.app.receivers.size() 表示的是一个app注册的所有的广播，MAX_RECEIVERS_ALLOWED_PER_APP是1000，什么意思？</span><br><span class="line">                //一个app最多只能注册1000个广播。</span><br><span class="line">                final int totalReceiversForApp = rl.app.receivers.size(); </span><br><span class="line">                if (totalReceiversForApp &gt;= MAX_RECEIVERS_ALLOWED_PER_APP) &#123;</span><br><span class="line">                    throw new IllegalStateException(&quot;Too many receivers, total of &quot;</span><br><span class="line">                            + totalReceiversForApp + &quot;, registered for pid: &quot;</span><br><span class="line">                            + rl.pid + &quot;, callerPackage: &quot; + callerPackage);</span><br><span class="line">                &#125;</span><br><span class="line">                rl.app.receivers.add(rl); //没超出最大数量，添加进去。</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    receiver.asBinder().linkToDeath(rl, 0);</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    return sticky;</span><br><span class="line">                &#125;</span><br><span class="line">                rl.linkedToDeath = true;</span><br><span class="line">            &#125;</span><br><span class="line">            //添加注册信息</span><br><span class="line">            mRegisteredReceivers.put(receiver.asBinder(), rl);</span><br><span class="line">        &#125;</span><br><span class="line">        //引入一个BroadcasrFilter，包含了上面的ReceiverList，本次广播的filter也存入BroadcastFilter中</span><br><span class="line">        BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage,</span><br><span class="line">                permission, callingUid, userId, instantApp, visibleToInstantApps);</span><br><span class="line">         rl.add(bf);  // bf中有rl,rl中有bf。你中有我，我中有你。同时这行代码的含义：向ReceiverList添加一个广播。等同于：当前activity又新注册了一个广播。</span><br><span class="line">        //IntentResolver&lt;BroadcastFilter, BroadcastFilter&gt; mReceiverResolver</span><br><span class="line">         mReceiverResolver.addFilter(bf); //到此处新增加的广播在AMS中就处理完毕了,下面还有一个粘性事件的分发处理。</span><br><span class="line">        // Enqueue broadcasts for all existing stickies that match</span><br><span class="line">        // this filter.</span><br><span class="line">        if (allSticky != null) &#123;//看样子要处理这个粘性事件的问题</span><br><span class="line">            ArrayList receivers = new ArrayList();</span><br><span class="line">            receivers.add(bf);</span><br><span class="line">            final int stickyCount = allSticky.size();</span><br><span class="line">            for (int i = 0; i &lt; stickyCount; i++) &#123;</span><br><span class="line">                Intent intent = allSticky.get(i);</span><br><span class="line">                //引入BroadcastQueue,两个队列：一个是前台队列，一个是后台队列。就是使用哪一个根据intent的flag来确定。</span><br><span class="line">                BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line">                //BroadcastRecord主要是包含了receivers</span><br><span class="line">                BroadcastRecord r = new BroadcastRecord(queue, intent, null,</span><br><span class="line">                        null, -1, -1, false, null, null, OP_NONE, null, receivers,</span><br><span class="line">                        null, 0, null, null, false, true, true, -1, false,</span><br><span class="line">                        false /* only PRE_BOOT_COMPLETED should be exempt, no stickies */);</span><br><span class="line">                queue.enqueueParallelBroadcastLocked(r); //入队</span><br><span class="line">                queue.scheduleBroadcastsLocked(); //分发广播</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sticky;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="对上面注册广播接收器进行小总结一下"><a href="#对上面注册广播接收器进行小总结一下" class="headerlink" title="对上面注册广播接收器进行小总结一下:"></a>对上面注册广播接收器进行小总结一下:</h5><ul>
<li>从app端过来的信息主要是IApplicationThread、IIntentReceiver、IntentFilter<ul>
<li><p>IApplicationThread用于确定到底是哪个app在搞事情</p>
</li>
<li><p>IIntentReceiver对标于Context, 而Context本身是一个Activity一个。那么这就产生一个问题：一个Activity注册多个广播，是怎么搞的？ </p>
<ul>
<li>答:mReceivers的数据类型是Map, key是Context, value是Map,key是broadcast,value 是ReceiverDispatcher.</li>
</ul>
</li>
<li><p>IntentFilter主要就是取其Action,标识其关注的广播。</p>
</li>
</ul>
</li>
<li>rl &#x3D; new ReceiverList(this, callerApp, callingPid, callingUid,userId, receiver);</li>
<li>mRegisteredReceivers.put(receiver.asBinder(), rl);</li>
<li>bf &#x3D; new BroadcastFilter(filter, rl, callerPackage,permission, callingUid, userId, instantApp, visibleToInstantApps);</li>
<li>mReceiverResolver.addFilter(bf);</li>
</ul>
<h4 id="上面广播的注册，处理的最多的还是这个粘性事件。同时通过上面代码的阅读，我们知道要是想获取一个粘性广播的消息，我们只需要这样"><a href="#上面广播的注册，处理的最多的还是这个粘性事件。同时通过上面代码的阅读，我们知道要是想获取一个粘性广播的消息，我们只需要这样" class="headerlink" title="上面广播的注册，处理的最多的还是这个粘性事件。同时通过上面代码的阅读，我们知道要是想获取一个粘性广播的消息，我们只需要这样"></a>上面广播的注册，处理的最多的还是这个粘性事件。同时通过上面代码的阅读，我们知道要是想获取一个粘性广播的消息，我们只需要这样</h4><p><strong>intent &#x3D; registerReceiver(null,IntentFliter(action)),这样从返回的这个intent，我们就可以获取到粘性事件的数据(当然也可能为null),如果你注册还是传入了receiver,又恰好有粘性事件，那么这正是我们下面要分析的：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">//接着分析上面遗留的小尾巴</span><br><span class="line">//queue.enqueueParallelBroadcastLocked(r); //入队</span><br><span class="line">    public void enqueueParallelBroadcastLocked(BroadcastRecord r) &#123;</span><br><span class="line">        mParallelBroadcasts.add(r); //类型是 ArrayList&lt;BroadcastRecord&gt; mParallelBroadcasts</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void enqueueOrderedBroadcastLocked(BroadcastRecord r) &#123;</span><br><span class="line">        mDispatcher.enqueueOrderedBroadcastLocked(r); //这个方法见名知意，当前广播加入有序广播</span><br><span class="line">    &#125;</span><br><span class="line">//queue.scheduleBroadcastsLocked(); //分发广播</span><br><span class="line">    public void scheduleBroadcastsLocked() &#123;</span><br><span class="line">        if (mBroadcastsScheduled) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //使用Handler去处理事情，这个Handler是在AMS构造的时候，创建的一个ServiceThread,继承自HandlerThread。</span><br><span class="line">        //也就是开了一个线程来处理这些广播分发的动作。</span><br><span class="line">        mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));</span><br><span class="line">        mBroadcastsScheduled = true;</span><br><span class="line">    &#125;</span><br><span class="line">//mHandler中调用processNextBroadcast(true);</span><br><span class="line">final void processNextBroadcast(boolean fromMsg) &#123;</span><br><span class="line">        synchronized (mService) &#123;</span><br><span class="line">            processNextBroadcastLocked(fromMsg, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">final void processNextBroadcastLocked(boolean fromMsg, boolean skipOomAdj) &#123;</span><br><span class="line">    while (mParallelBroadcasts.size() &gt; 0) &#123;</span><br><span class="line">        r = mParallelBroadcasts.remove(0);</span><br><span class="line">        final int N = r.receivers.size();</span><br><span class="line">        for (int i=0; i&lt;N; i++) &#123;//开启for循环的时候就是故事开始的时候</span><br><span class="line">            Object target = r.receivers.get(i);</span><br><span class="line">            //分发</span><br><span class="line">            deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false, i);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">private void deliverToRegisteredReceiverLocked(BroadcastRecord r,</span><br><span class="line">        BroadcastFilter filter, boolean ordered, int index) &#123;</span><br><span class="line">    boolean skip = false;</span><br><span class="line">    ...</span><br><span class="line">    if (skip) &#123;</span><br><span class="line">    r.delivery[index] = BroadcastRecord.DELIVERY_SKIPPED;</span><br><span class="line">    return;</span><br><span class="line">    &#125;</span><br><span class="line">   if (filter.receiverList.app != null &amp;&amp; filter.receiverList.app.inFullBackup) &#123;</span><br><span class="line">                // Skip delivery if full backup in progress</span><br><span class="line">                // If it&#x27;s an ordered broadcast, we need to continue to the next receiver.</span><br><span class="line">                if (ordered) &#123;</span><br><span class="line">                    skipReceiverLocked(r); //这里面有点意思，通过下面的分析就知道，这里进行了循环。</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                maybeAddAllowBackgroundActivityStartsToken(filter.receiverList.app, r);</span><br><span class="line">                //分发</span><br><span class="line">                performReceiveLocked(filter.receiverList.app, filter.receiverList.receiver,</span><br><span class="line">                        new Intent(r.intent), r.resultCode, r.resultData,</span><br><span class="line">                        r.resultExtras, r.ordered, r.initialSticky, r.userId);</span><br><span class="line">                // parallel broadcasts are fire-and-forget, not bookended by a call to</span><br><span class="line">                // finishReceiverLocked(), so we manage their activity-start token here</span><br><span class="line">                if (r.allowBackgroundActivityStarts &amp;&amp; !r.ordered) &#123;</span><br><span class="line">                    postActivityStartTokenRemoval(filter.receiverList.app, r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (ordered) &#123;</span><br><span class="line">                r.state = BroadcastRecord.CALL_DONE_RECEIVE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//skipReceiverLocked</span><br><span class="line">private void skipReceiverLocked(BroadcastRecord r) &#123;</span><br><span class="line">        logBroadcastReceiverDiscardLocked(r);</span><br><span class="line">        finishReceiverLocked(r, r.resultCode, r.resultData,</span><br><span class="line">                r.resultExtras, r.resultAbort, false);</span><br><span class="line">        scheduleBroadcastsLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    public void scheduleBroadcastsLocked() &#123;</span><br><span class="line">        if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Schedule broadcasts [&quot;</span><br><span class="line">                + mQueueName + &quot;]: current=&quot;</span><br><span class="line">                + mBroadcastsScheduled);</span><br><span class="line">        if (mBroadcastsScheduled) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));</span><br><span class="line">        mBroadcastsScheduled = true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="最后的派发performReceiveLocked"><a href="#最后的派发performReceiveLocked" class="headerlink" title="最后的派发performReceiveLocked"></a>最后的派发performReceiveLocked</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver,</span><br><span class="line">        Intent intent, int resultCode, String data, Bundle extras,</span><br><span class="line">        boolean ordered, boolean sticky, int sendingUser)</span><br><span class="line">        throws RemoteException &#123;</span><br><span class="line">    // Send the intent to the receiver asynchronously using one-way binder calls.</span><br><span class="line">    if (app != null) &#123;</span><br><span class="line">        if (app.thread != null) &#123;</span><br><span class="line">//走这里从applicationThread进行RPC,binder通信回调回去。注意上面的注释，说这个事one-way也就是单向，调用了就行，不需要等待回复的。</span><br><span class="line">//进入ActivityThread我们会发现，其实调用的就是receiver.performReceive</span><br><span class="line">                app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,</span><br><span class="line">                        data, extras, ordered, sticky, sendingUser, app.getReportedProcState());</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">//这里就不一样了使用IIntentReceiver，这里的receiver是代理端，发起远程RPC,回调回LoadedApk中,进行广播派发。</span><br><span class="line">        receiver.performReceive(intent, resultCode, data, extras, ordered,</span><br><span class="line">                sticky, sendingUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>上面的消息派发都是使用receiver.performReceive，有什么区别了？使用applicationThread回调回去的，是在app自己的进程派发。在AMS中调用receiver.performReceive时跨进程的binder call调用派发消息。</strong></p>
<h4 id="万万没有想到我只是想分析一下广播的注册，没想到分发也引入进来了。ok-话不多说，接着我们真正的开始广播的发送。"><a href="#万万没有想到我只是想分析一下广播的注册，没想到分发也引入进来了。ok-话不多说，接着我们真正的开始广播的发送。" class="headerlink" title="万万没有想到我只是想分析一下广播的注册，没想到分发也引入进来了。ok,话不多说，接着我们真正的开始广播的发送。"></a>万万没有想到我只是想分析一下广播的注册，没想到分发也引入进来了。ok,话不多说，接着我们真正的开始广播的发送。</h4><ul>
<li>sendBroadcast()    普通广播</li>
<li>sendOrderedBroadcast    有序广播</li>
<li>sendStickyBroadcast ，Sticky broadcasts should not be used. 粘性广播在高版本的API上已经被废弃掉了，后面的解释说是任何用户都可以访问，同时也可以修改，非常的不安全！</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#ContextImpl$sendBroadcast</span><br><span class="line">@Override</span><br><span class="line">public void sendBroadcast(Intent intent) &#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());</span><br><span class="line">    try &#123;</span><br><span class="line">        intent.prepareToLeaveProcess(this);</span><br><span class="line">        //发送不是注册，不需要考虑如何接收的问题，因此来的简单粗暴一些。带上Intent,直接就进入AMS中</span><br><span class="line">        ActivityManager.getService().broadcastIntent(</span><br><span class="line">                mMainThread.getApplicationThread(), intent, resolvedType, null,</span><br><span class="line">                Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false,</span><br><span class="line">                getUserId());</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="进入AMS去查看broadcastIntent"><a href="#进入AMS去查看broadcastIntent" class="headerlink" title="进入AMS去查看broadcastIntent"></a>进入AMS去查看broadcastIntent</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">final int broadcastIntentLocked(ProcessRecord callerApp,</span><br><span class="line">        String callerPackage, Intent intent, String resolvedType,</span><br><span class="line">        IIntentReceiver resultTo, int resultCode, String resultData,</span><br><span class="line">        Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle bOptions,</span><br><span class="line">        boolean ordered, boolean sticky, int callingPid, int callingUid, int realCallingUid,</span><br><span class="line">        int realCallingPid, int userId, boolean allowBackgroundActivityStarts) &#123;</span><br><span class="line">    intent = new Intent(intent);//重新构建一个本地的Intent，这是为何？</span><br><span class="line">  // By default broadcasts do not go to stopped apps.</span><br><span class="line">intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES); //停止的app不在派发</span><br><span class="line">final String action = intent.getAction();</span><br><span class="line">if (action != null) &#123;</span><br><span class="line">    switch (action) &#123; //下面的这些ACTION,看到名字就知道是PKMS发送过来的，</span><br><span class="line">        case Intent.ACTION_PACKAGE_REMOVED: //当app移除，就会去清除当前app的堆栈信息，具体的等分析PKMS再来进行分析。</span><br><span class="line">        case Intent.ACTION_PACKAGE_CHANGED:</span><br><span class="line">        ...</span><br><span class="line">if (sticky) &#123;</span><br><span class="line">    //上面我们看到发送粘性广播的API已经废弃，但是这里面还是有的，应该是留给系统使用的，需要一个权限：android.permission.BROADCAST_STICKY</span><br><span class="line">    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,</span><br><span class="line">            callingPid, callingUid)</span><br><span class="line">            != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">        throw new SecurityException(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(userId);</span><br><span class="line">    if (stickies == null) &#123;</span><br><span class="line">        stickies = new ArrayMap&lt;&gt;();</span><br><span class="line">        mStickyBroadcasts.put(userId, stickies); //粘性广播加入集合</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Intent&gt; list = stickies.get(intent.getAction());</span><br><span class="line">    if (list == null) &#123;</span><br><span class="line">        list = new ArrayList&lt;&gt;();</span><br><span class="line">        stickies.put(intent.getAction(), list);&#125;</span><br><span class="line">    final int stickiesCount = list.size();</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; stickiesCount; i++) &#123;</span><br><span class="line">    if (intent.filterEquals(list.get(i))) &#123;</span><br><span class="line">        // This sticky already exists, replace it.</span><br><span class="line">        list.set(i, new Intent(intent));</span><br><span class="line">        break;&#125;&#125;</span><br><span class="line">if (i &gt;= stickiesCount) &#123;</span><br><span class="line">    list.add(new Intent(intent));&#125;&#125; </span><br><span class="line">//上面完成了对粘性消息的处理</span><br><span class="line">// Figure out who all will receive this broadcast. </span><br><span class="line">List receivers = null; //看来要开始找出接收者了</span><br><span class="line">List&lt;BroadcastFilter&gt; registeredReceivers = null;</span><br><span class="line">if ((intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY)// 设置了这个Flag表示只分发给动态广播，没设置，默认，走下面去PKMS中把静态广播也一起找出来。</span><br><span class="line">         == 0) &#123;</span><br><span class="line"> //这个receivers是List&lt;ResolveInfo&gt;，并且下面这个方法看一下就知道，是在访问PKMS,找到匹配当前Intent的广播接收器</span><br><span class="line">    receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);</span><br><span class="line">&#125;</span><br><span class="line">//这个mReceiverResolver在注册广播的时候，最后: mReceiverResolver.addFliter(bf),看来就在这里去匹配的</span><br><span class="line">//所有动态注册的广播，全部出场，最后还有一个mResolvePrioritySorter,用于按照优先级排序，看来已经考虑到顺序广播。</span><br><span class="line">    registeredReceivers = mReceiverResolver.queryIntent(intent,</span><br><span class="line">        resolvedType, false /*defaultOnly*/, userId);</span><br><span class="line">// Merge into one list. 要给静态广播和动态合并在一块好进行一个分发</span><br><span class="line">if (receivers != null) &#123; //如果静态广播不为空</span><br><span class="line">    // A special case for PACKAGE_ADDED: do not allow the package</span><br><span class="line">    // being added to see this broadcast.  This prevents them from</span><br><span class="line">    // using this as a back door to get run as soon as they are</span><br><span class="line">    // installed.   </span><br><span class="line">    //上面这段注释加上下面这段代码的意思就是：</span><br><span class="line">    //当前的这个广播如果是下面几种类型的，同时我们搜索到的静态广播也监听这几个action,那么就应该把这几个静态广播移除出去，</span><br><span class="line">    //这样就可以避免一种情况就是：1. 应用刚安装就自己启动了，2. 用户刚点击了清除应用数据，应用就启动了。</span><br><span class="line">    String skipPackages[] = null;</span><br><span class="line">    if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())</span><br><span class="line">            || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction())</span><br><span class="line">            || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) &#123;</span><br><span class="line">        Uri data = intent.getData();</span><br><span class="line">        if (data != null) &#123;</span><br><span class="line">            String pkgName = data.getSchemeSpecificPart();</span><br><span class="line">            if (pkgName != null) &#123;</span><br><span class="line">                skipPackages = new String[] &#123; pkgName &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) &#123;</span><br><span class="line">        skipPackages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);</span><br><span class="line">    &#125;</span><br><span class="line">    if (skipPackages != null &amp;&amp; (skipPackages.length &gt; 0)) &#123;</span><br><span class="line">        for (String skipPackage : skipPackages) &#123;</span><br><span class="line">            if (skipPackage != null) &#123;</span><br><span class="line">                int NT = receivers.size();</span><br><span class="line">                for (int it=0; it&lt;NT; it++) &#123;</span><br><span class="line">                    ResolveInfo curt = (ResolveInfo)receivers.get(it);</span><br><span class="line">                    if (curt.activityInfo.packageName.equals(skipPackage)) &#123;</span><br><span class="line">                        receivers.remove(it);</span><br><span class="line">                        it--;</span><br><span class="line">                        NT--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //通过上面的移除，下面要真正的开始将静态和动态广播合并到一个了</span><br><span class="line">    int NT = receivers != null ? receivers.size() : 0;</span><br><span class="line">    int it = 0;</span><br><span class="line">    int ir = 0;</span><br><span class="line">    ResolveInfo curt = null;// 静态广播对应数据类型</span><br><span class="line">    BroadcastFilter curr = null;// 动态广播对应类型</span><br><span class="line">    //注意到上面两种广播的数据类型根本不一样，两种类型不一样的要合并在一起，这是一个有趣的事情，看看google工程师怎么搞的事情：</span><br><span class="line">    while (it &lt; NT &amp;&amp; ir &lt; NR) &#123;</span><br><span class="line">        if (curt == null) &#123;</span><br><span class="line">            curt = (ResolveInfo)receivers.get(it); //取出第it个静态广播</span><br><span class="line">        &#125;</span><br><span class="line">        if (curr == null) &#123;</span><br><span class="line">            curr = registeredReceivers.get(ir); //取出第ir个动态广播</span><br><span class="line">        &#125;</span><br><span class="line">        if (curr.getPriority() &gt;= curt.priority) &#123; //两个广播进行优先级比较</span><br><span class="line">            // Insert this broadcast record into the final list.</span><br><span class="line">            receivers.add(it, curr);//？？动态的BroadcastFilter 插入静态的ResolveInfo列表？？不是，等等，这个类型不是不一样嘛</span><br><span class="line">            ir++;</span><br><span class="line">            curr = null; //准备取下一个动态</span><br><span class="line">            it++;</span><br><span class="line">            NT++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Skip to the next ResolveInfo in the final list.</span><br><span class="line">            it++;</span><br><span class="line">            curt = null; //静态广播优先级大，在这个位置不动，取下一个静态广播和当前动态广播相比较</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">while (ir &lt; NR) &#123; //动态广播还没有取完，把最后剩于的加入列表末尾。</span><br><span class="line">    if (receivers == null) &#123;</span><br><span class="line">        receivers = new ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line">    receivers.add(registeredReceivers.get(ir));</span><br><span class="line">    ir++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="上面把动态广播的BroadcastFilter加入静态receivers-ResolveInfo-List的动作-是因为List-receivers-null-这个List没有指定是什么类型的，默认存放的是Object类型，所以静态动态被存放在了同一个里面。另外我们已经得到能够接收的列表，而且按照优先权来拍好了序，看来就只差最后一步了：分发。"><a href="#上面把动态广播的BroadcastFilter加入静态receivers-ResolveInfo-List的动作-是因为List-receivers-null-这个List没有指定是什么类型的，默认存放的是Object类型，所以静态动态被存放在了同一个里面。另外我们已经得到能够接收的列表，而且按照优先权来拍好了序，看来就只差最后一步了：分发。" class="headerlink" title="上面把动态广播的BroadcastFilter加入静态receivers(ResolveInfo) List的动作,是因为List receivers &#x3D; null; 这个List没有指定是什么类型的，默认存放的是Object类型，所以静态动态被存放在了同一个里面。另外我们已经得到能够接收的列表，而且按照优先权来拍好了序，看来就只差最后一步了：分发。"></a>上面把动态广播的BroadcastFilter加入静态receivers(ResolveInfo) List的动作,是因为List receivers &#x3D; null; 这个List没有指定是什么类型的，默认存放的是Object类型，所以静态动态被存放在了同一个里面。另外我们已经得到能够接收的列表，而且按照优先权来拍好了序，看来就只差最后一步了：分发。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line">if ((receivers != null &amp;&amp; receivers.size() &gt; 0)</span><br><span class="line">        || resultTo != null) &#123;</span><br><span class="line">    //之前分析过，拿queue</span><br><span class="line">    BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line">    //这些准备分发的接收器信息封装在BroadcastRecord中</span><br><span class="line">    BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,</span><br><span class="line">            callerPackage, callingPid, callingUid, callerInstantApp, resolvedType,</span><br><span class="line">            requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode,</span><br><span class="line">            resultData, resultExtras, ordered, sticky, false, userId,</span><br><span class="line">            allowBackgroundActivityStarts, timeoutExempt);</span><br><span class="line">   //注意了，这里入的队是有序的</span><br><span class="line">        queue.enqueueOrderedBroadcastLocked(r);</span><br><span class="line">   //分发</span><br><span class="line">        queue.scheduleBroadcastsLocked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">public void enqueueOrderedBroadcastLocked(BroadcastRecord r) &#123;</span><br><span class="line">    mDispatcher.enqueueOrderedBroadcastLocked(r);</span><br><span class="line">    enqueueBroadcastHelper(r);</span><br><span class="line">&#125;</span><br><span class="line">void enqueueOrderedBroadcastLocked(BroadcastRecord r) &#123;</span><br><span class="line">// ArrayList&lt;BroadcastRecord&gt; mOrderedBroadcasts = new ArrayList&lt;&gt;();</span><br><span class="line">    mOrderedBroadcasts.add(r);</span><br><span class="line">&#125;</span><br><span class="line">//这个 queue.scheduleBroadcastsLocked();我们已经看过了，使用handler发个消息开始分发，然后</span><br><span class="line">final void processNextBroadcastLocked(boolean fromMsg, boolean skipOomAdj) &#123;</span><br><span class="line">    BroadcastRecord r;</span><br><span class="line">    while (mParallelBroadcasts.size() &gt; 0) &#123; //分发无序的广播</span><br><span class="line">    &#125;</span><br><span class="line">    do &#123;</span><br><span class="line">    // 获取一个又一个的BroadcastRecord </span><br><span class="line">    r = mDispatcher.getNextBroadcastLocked(now);</span><br><span class="line">    </span><br><span class="line">        &#125; while (r == null);</span><br><span class="line">    // Get the next receiver...</span><br><span class="line">   int recIdx = r.nextReceiver++;</span><br><span class="line">   final Object nextReceiver = r.receivers.get(recIdx);</span><br><span class="line">   if (nextReceiver instanceof BroadcastFilter) &#123; //动态广播</span><br><span class="line">        //分发，这里就不去分析这个动态广播的分发了，上面已经分析过了。</span><br><span class="line">        deliverToRegisteredReceiverLocked(r, filter, r.ordered, recIdx);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //静态广播的分发</span><br><span class="line">    ResolveInfo info =</span><br><span class="line">    (ResolveInfo)nextReceiver;</span><br><span class="line">    // 一系列的判断，判断要接收的apk是否有权限</span><br><span class="line">  // Is this receiver&#x27;s application already running?</span><br><span class="line">    if (app != null &amp;&amp; app.thread != null &amp;&amp; !app.killed) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            app.addPackage(info.activityInfo.packageName,</span><br><span class="line">                    info.activityInfo.applicationInfo.longVersionCode, mService.mProcessStats);</span><br><span class="line">            maybeAddAllowBackgroundActivityStartsToken(app, r);</span><br><span class="line">            processCurBroadcastLocked(r, app, skipOomAdj); //注意在这里</span><br><span class="line">            return;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    //startProcessLocked完成了app的启动，看下面这条注释，当app启动再去执行广播。</span><br><span class="line">    // Not running -- get it started, to be executed when the app comes up.</span><br><span class="line">    if ((r.curApp=mService.startProcessLocked(targetProcess,</span><br><span class="line">            info.activityInfo.applicationInfo, true,</span><br><span class="line">            r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND,</span><br><span class="line">            new HostingRecord(&quot;broadcast&quot;, r.curComponent),</span><br><span class="line">            (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) != 0, false, false))</span><br><span class="line">                    == null) &#123;</span><br><span class="line">        // Ah, this recipient is unavailable.  Finish it if necessary,</span><br><span class="line">        // and mark the broadcast record as ready for the next.</span><br><span class="line">        Slog.w(TAG, &quot;Unable to launch app &quot;</span><br><span class="line">                + info.activityInfo.applicationInfo.packageName + &quot;/&quot;</span><br><span class="line">                + receiverUid + &quot; for broadcast &quot;</span><br><span class="line">                + r.intent + &quot;: process is bad&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">   //结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分析上面的processCurBroadcastLocked，问题应该就在这里了："><a href="#分析上面的processCurBroadcastLocked，问题应该就在这里了：" class="headerlink" title="分析上面的processCurBroadcastLocked，问题应该就在这里了："></a>分析上面的processCurBroadcastLocked，问题应该就在这里了：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//多么熟悉的姿势</span><br><span class="line">app.thread.scheduleReceiver(new Intent(r.intent), r.curReceiver,</span><br><span class="line">        mService.compatibilityInfoForPackage(r.curReceiver.applicationInfo),</span><br><span class="line">        r.resultCode, r.resultData, r.resultExtras, r.ordered, r.userId,</span><br><span class="line">        app.getReportedProcState());</span><br><span class="line">//接着进入ApplicationThread中</span><br><span class="line">public final void scheduleReceiver(Intent intent, ActivityInfo info,</span><br><span class="line">        CompatibilityInfo compatInfo, int resultCode, String data, Bundle extras,</span><br><span class="line">        boolean sync, int sendingUser, int processState) &#123;</span><br><span class="line">    updateProcessState(processState, false);</span><br><span class="line">    ReceiverData r = new ReceiverData(intent, resultCode, data, extras,</span><br><span class="line">            sync, false, mAppThread.asBinder(), sendingUser);</span><br><span class="line">    r.info = info;</span><br><span class="line">    r.compatInfo = compatInfo;</span><br><span class="line">    sendMessage(H.RECEIVER, r); //使用mH去发送这个广播接收的消息</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)</span><br><span class="line">private void handleReceiver(ReceiverData data) &#123;</span><br><span class="line">    IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">    Application app;</span><br><span class="line">    BroadcastReceiver receiver;</span><br><span class="line">    ContextImpl context;</span><br><span class="line">    try &#123;</span><br><span class="line">        app = packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line">        context = (ContextImpl) app.getBaseContext();</span><br><span class="line">        //类加载器也安排上了，看来是要搞事情了</span><br><span class="line">        java.lang.ClassLoader cl = context.getClassLoader();</span><br><span class="line">        //下面这个instantiateReceiver，代码是(BroadcastReceiver) cl.loadClass(className).newInstance();</span><br><span class="line">        //果然，反射加载了我们的静态广播接收器</span><br><span class="line">        receiver = packageInfo.getAppFactory()</span><br><span class="line">                .instantiateReceiver(cl, data.info.name, data.intent);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        receiver.setPendingResult(data);</span><br><span class="line">        //一个轻快的函数调用，至此进入onReceiver方法，收到消息。</span><br><span class="line">        receiver.onReceive(context.getReceiverRestrictedContext(),</span><br><span class="line">                data.intent);</span><br><span class="line">    &#125;</span><br><span class="line">    if (receiver.getPendingResult() != null) &#123;</span><br><span class="line">        data.finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="上面还遗留一个问题就是：要是app没有启动，那么这个广播是怎么分发的？"><a href="#上面还遗留一个问题就是：要是app没有启动，那么这个广播是怎么分发的？" class="headerlink" title="上面还遗留一个问题就是：要是app没有启动，那么这个广播是怎么分发的？"></a>上面还遗留一个问题就是：要是app没有启动，那么这个广播是怎么分发的？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">//mService.startProcessLocked(...)  这个是AMS</span><br><span class="line">mProcessList.startProcessLocked(...)</span><br><span class="line"></span><br><span class="line">final ProcessRecord startProcessLocked(String processName, ApplicationInfo info,</span><br><span class="line">        boolean knownToBeDead, int intentFlags, HostingRecord hostingRecord,</span><br><span class="line">        boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge,</span><br><span class="line">        String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler) &#123;</span><br><span class="line">    long startTime = SystemClock.elapsedRealtime();</span><br><span class="line">    ProcessRecord app;</span><br><span class="line">    if (!isolated) &#123;</span><br><span class="line">        //app没有启动，所以这里的app是null</span><br><span class="line">        app = getProcessRecordLocked(processName, info.uid, keepIfLarge);</span><br><span class="line">    &#125;</span><br><span class="line">if (app == null) &#123;</span><br><span class="line">    //注意这里，构建ProcessRecord</span><br><span class="line">    app = newProcessRecordLocked(info, processName, isolated, isolatedUid, hostingRecord);</span><br><span class="line">    app.crashHandler = crashHandler;</span><br><span class="line">&#125; </span><br><span class="line">//注意这里,启动Process</span><br><span class="line">final boolean success = startProcessLocked(app, hostingRecord, abiOverride);</span><br><span class="line">&#125;</span><br><span class="line">//分析构建Process</span><br><span class="line">final ProcessRecord newProcessRecordLocked(ApplicationInfo info, String customProcess,</span><br><span class="line">        boolean isolated, int isolatedUid, HostingRecord hostingRecord) &#123;</span><br><span class="line">        final ProcessRecord r = new ProcessRecord(mService, info, proc, uid);</span><br><span class="line">        addProcessNameLocked(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final void addProcessNameLocked(ProcessRecord proc) &#123;</span><br><span class="line">    mProcessNames.put(proc.processName, proc.uid, proc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//启动Process</span><br><span class="line">final boolean startProcessLocked(ProcessRecord app, HostingRecord hostingRecord,</span><br><span class="line">        String abiOverride) &#123;</span><br><span class="line">    return startProcessLocked(app, hostingRecord,</span><br><span class="line">            false /* disableHiddenApiChecks */, false /* mountExtStorageFull */, abiOverride);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boolean startProcessLocked(HostingRecord hostingRecord,</span><br><span class="line">        String entryPoint,</span><br><span class="line">        ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal,</span><br><span class="line">        String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span><br><span class="line">        long startTime) &#123;</span><br><span class="line">final Process.ProcessStartResult startResult = startProcess(hostingRecord,</span><br><span class="line">        entryPoint, app,</span><br><span class="line">        uid, gids, runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet,</span><br><span class="line">        invokeWith, startTime);</span><br><span class="line">handleProcessStartedLocked(app, startResult.pid, startResult.usingWrapper,</span><br><span class="line">        startSeq, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Process.ProcessStartResult startProcess(HostingRecord hostingRecord, String entryPoint,</span><br><span class="line">        ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal,</span><br><span class="line">        String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span><br><span class="line">        long startTime) &#123;</span><br><span class="line">final Process.ProcessStartResult startResult;</span><br><span class="line">if (hostingRecord.usesWebviewZygote()) &#123;  //启动WebView</span><br><span class="line">    startResult = startWebView(entryPoint,</span><br><span class="line">            app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">            app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">            app.info.dataDir, null, app.info.packageName,</span><br><span class="line">            new String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">&#125; else if (hostingRecord.usesAppZygote()) &#123; //应用程序的Zygote</span><br><span class="line">    final AppZygote appZygote = createAppZygoteForProcessIfNeeded(app);</span><br><span class="line">    startResult = appZygote.getProcess().start(entryPoint,</span><br><span class="line">            app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">            app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">            app.info.dataDir, null, app.info.packageName,</span><br><span class="line">            /*useUsapPool=*/ false,</span><br><span class="line">            new String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">//走这</span><br><span class="line">    startResult = Process.start(entryPoint,</span><br><span class="line">            app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">            app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">            app.info.dataDir, invokeWith, app.info.packageName,</span><br><span class="line">            new String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">&#125;</span><br><span class="line">checkSlow(startTime, &quot;startProcess: returned from zygote!&quot;);</span><br><span class="line">return startResult;</span><br><span class="line">&#125;</span><br><span class="line">#Process.java</span><br><span class="line">public static ProcessStartResult start(@NonNull final String processClass,</span><br><span class="line">                                       @Nullable final String niceName,</span><br><span class="line">                                       int uid, int gid, @Nullable int[] gids,</span><br><span class="line">                                       int runtimeFlags,</span><br><span class="line">                                       int mountExternal,</span><br><span class="line">                                       int targetSdkVersion,</span><br><span class="line">                                       @Nullable String seInfo,</span><br><span class="line">                                       @NonNull String abi,</span><br><span class="line">                                       @Nullable String instructionSet,</span><br><span class="line">                                       @Nullable String appDataDir,</span><br><span class="line">                                       @Nullable String invokeWith,</span><br><span class="line">                                       @Nullable String packageName,</span><br><span class="line">                                       @Nullable String[] zygoteArgs) &#123;</span><br><span class="line">    //这个类型 ZygoteProcess ZYGOTE_PROCESS = new ZygoteProcess();</span><br><span class="line">    return ZYGOTE_PROCESS.start(processClass, niceName, uid, gid, gids,</span><br><span class="line">                runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                abi, instructionSet, appDataDir, invokeWith, packageName,</span><br><span class="line">                /*useUsapPool=*/ true, zygoteArgs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">        runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">        abi, instructionSet, appDataDir, invokeWith, /*startChildZygote=*/ false,</span><br><span class="line">        packageName, useUsapPool, zygoteArgs);</span><br><span class="line">//最后调用到</span><br><span class="line">private Process.ProcessStartResult attemptZygoteSendArgsAndGetResult(</span><br><span class="line">        ZygoteState zygoteState, String msgStr) throws ZygoteStartFailedEx &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        final BufferedWriter zygoteWriter = zygoteState.mZygoteOutputWriter;</span><br><span class="line">        final DataInputStream zygoteInputStream = zygoteState.mZygoteInputStream;</span><br><span class="line"></span><br><span class="line">        zygoteWriter.write(msgStr); //写入数据 ，其实我们知道这个就是通过Socket给zygote发送消息，让他fork一个新的进程，由此一个app产生！</span><br><span class="line">        zygoteWriter.flush(); //刷新缓冲区</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125; catch (IOException ex) &#123;</span><br><span class="line">        zygoteState.close();</span><br><span class="line">        Log.e(LOG_TAG, &quot;IO Exception while communicating with Zygote - &quot;</span><br><span class="line">                + ex.toString());</span><br><span class="line">        throw new ZygoteStartFailedEx(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花."></a>完结撒花.</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/24/20250324/" data-id="cmdmr0kna0001zsu14nv8hhjz" data-title="Android源码阅读之———广播的注册与分发" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/08/">August 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/08/21/C-C-%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%8C/">C/C++基础之二(类的构造函数)</a>
          </li>
        
          <li>
            <a href="/2025/08/20/C-C-%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%B8%80/">C/C++基础之一</a>
          </li>
        
          <li>
            <a href="/2025/03/24/20250324/">Android源码阅读之———广播的注册与分发</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 Cherry<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>